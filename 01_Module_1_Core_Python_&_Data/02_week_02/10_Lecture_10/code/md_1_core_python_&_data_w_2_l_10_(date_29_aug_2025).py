# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#2_L#10_(Date:29-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j-ranW0fsZ7r5QQNaTGvDLXLPYPLrVFn

# üß† Module 1: Core Python & Data - Week 2 Lecture 10
**Date:** 29/08/2025  
**Documented by:** Muhammad Soban Shaukat

## üèóÔ∏è A New Way of Thinking: Introduction to Object-Oriented Programming (OOP)

We've mastered functions for reusable code. But as programs grow, we need a better way to manage complexity. Welcome to **Object-Oriented Programming (OOP)** ‚Äì the foundation of modern software. It's not just new syntax; it's a new way to think about problems.

---

Yesterday's focus was **Encapsulation** (bundling data & methods). But OOP is built on three other powerful ideas. Let's explore them briefly.

## 2. üë®‚Äçüë©‚Äçüëß‚Äçüë¶ The Power of Inheritance

Inheritance allows a new class (**child**) to reuse and extend the functionality of an existing class (**parent**). This promotes code reusability and a logical hierarchy.

*   **Syntax:** `class ChildClass(ParentClass):`
*   **`super()`:** Function used to call methods from the parent class.
"""

# Inheritance Example: Animals
class Animal:
    def __init__(self, name):
        self.name = name

    def eat(self):
        print(f"{self.name} is eating.")

    def sleep(self):
        print(f"{self.name} is sleeping.")

# Dog inherits from Animal
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Call parent's __init__
        self.breed = breed      # New attribute specific to Dog

    # New method specific to Dog
    def bark(self):
        print(f"{self.name} says: Woof!")

    # Overriding parent's method
    def eat(self):
        print(f"{self.name} the {self.breed} wolfs down its food!")

# Cat also inherits from Animal
class Cat(Animal):
    def meow(self):
        print(f"{self.name} says: Meow!")

# Create objects
my_dog = Dog("Rex", "Labrador")
my_cat = Cat("Whiskers")

# Inherited methods
my_dog.eat()    # Uses overridden version
my_cat.eat()    # Uses parent's version
my_dog.sleep()  # Uses inherited method
my_cat.sleep()  # Uses inherited method

# Child-specific methods
my_dog.bark()
my_cat.meow()

print(f"{my_dog.name} is a {my_dog.breed}.")

"""## 3. #Ô∏è‚É£ The Power of Polymorphism

Polymorphism means "many forms". It allows objects of different classes to be treated as objects of a common superclass. The same method call can behave differently depending on the object's class.
"""

# Polymorphism Example
print("=== Fixed Polymorphism Example ===")

# First, let's define a proper Dog class with make_sound method
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def make_sound(self):
        print(f"{self.name} the {self.breed} says: Woof woof!")

    def wag_tail(self):
        print(f"{self.name} is wagging its tail happily!")

class Bird:
    def make_sound(self):
        print("Chirp chirp!")

    def fly(self):
        print("Flying high in the sky!")

class Cow:
    def make_sound(self):
        print("Moo!")

    def graze(self):
        print("Grazing in the field")

# Polymorphism function - works with ANY object that has make_sound()
def animal_sounds(animals):
    print("\nüéµ Animal Concert Starting! üéµ")
    for animal in animals:
        animal.make_sound()  # This will work for all objects now

# Create a list of different objects
farm_animals = [
    Bird(),
    Cow(),
    Dog("Buddy", "Beagle"),
    Dog("Luna", "Golden Retriever")
]

# The same function works for all!
animal_sounds(farm_animals)

# Let's also demonstrate that each class can have unique methods
print("\n=== Unique Animal Behaviors ===")
for animal in farm_animals:
    if hasattr(animal, 'fly'):
        animal.fly()
    elif hasattr(animal, 'graze'):
        animal.graze()
    elif hasattr(animal, 'wag_tail'):
        animal.wag_tail()

# Even better: Using inheritance for true polymorphism
print("\n=== Enhanced Polymorphism with Inheritance ===")

class Animal:
    def make_sound(self):
        pass  # To be overridden by subclasses

class Dog(Animal):
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def make_sound(self):
        print(f"{self.name} the {self.breed} says: Woof woof!")

class Bird(Animal):
    def make_sound(self):
        print("Chirp chirp!")

class Cow(Animal):
    def make_sound(self):
        print("Moo!")

# Now we can be sure all animals have make_sound()
proper_animals = [
    Bird(),
    Cow(),
    Dog("Buddy", "Beagle"),
    Dog("Luna", "Golden Retriever")
]

def better_animal_sounds(animals):
    print("\nüéµ Better Animal Concert! üéµ")
    for animal in animals:
        animal.make_sound()

better_animal_sounds(proper_animals)

# We can also check if they're all Animals
print(f"\nAll are Animals: {all(isinstance(animal, Animal) for animal in proper_animals)}")

# Most robust: Using abstract base classes
print("\n=== Most Robust: Using Abstract Base Classes ===")

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(Animal):
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def make_sound(self):
        print(f"{self.name} the {self.breed} says: Woof woof!")

class Bird(Animal):
    def make_sound(self):
        print("Chirp chirp!")

class Cow(Animal):
    def make_sound(self):
        print("Moo!")

# This ensures ALL animals have make_sound()
robust_animals = [
    Bird(),
    Cow(),
    Dog("Buddy", "Beagle")
]

def robust_animal_sounds(animals):
    print("\nüéµ Robust Animal Concert! üéµ")
    for animal in animals:
        animal.make_sound()

robust_animal_sounds(robust_animals)

# Try to create an animal without make_sound - this will fail!
try:
    class InvalidAnimal(Animal):
        pass  # Doesn't implement make_sound

    invalid = InvalidAnimal()
except TypeError as e:
    print(f"\n‚úÖ Properly prevented invalid animal: {e}")

"""## 4. üî∑ Hands-On Lab: The Shape Class

**Goal:** Create a hierarchy of shapes where each shape can calculate its area, demonstrating inheritance and polymorphism.

**Step-by-Step Instructions:**
### Part 1: The Blueprint (Base Class)
"""

# Base Class: Shape
class Shape:
    def area(self):
        pass  # Placeholder - to be overridden by child classes

    # A common method for all shapes
    def describe(self):
        print("I am a shape.")

"""### Part 2: Adding Behaviors (Child Classes)"""

# Child Class: Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    # Override the area method
    def area(self):
        return 3.14159 * self.radius ** 2

    # Override describe method
    def describe(self):
        print(f"I am a circle with radius {self.radius}.")

# Child Class: Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    # Override the area method
    def area(self):
        return self.width * self.height

    # Override describe method
    def describe(self):
        print(f"I am a rectangle {self.width}x{self.height}.")

"""### Part 3: Testing Your Classes"""

# Create different shapes
shapes = [
    Circle(5),
    Rectangle(4, 6),
    Circle(3),
    Rectangle(2, 8)
]

# Demonstrate polymorphism
print("=== Shape Areas ===")
total_area = 0
for shape in shapes:
    shape.describe()
    area = shape.area()
    print(f"My area is: {area:.2f}")
    total_area += area
    print("---")

print(f"Total area of all shapes: {total_area:.2f}")

"""### üß† Challenge: Add a Triangle Class"""

# Challenge: Triangle Class
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

    def describe(self):
        print(f"I am a triangle with base {self.base} and height {self.height}.")

# Test the Triangle
shapes.append(Triangle(6, 4))
print(f"Triangle area: {shapes[-1].area()}")

"""## 4. üì∫ The Power of Abstraction

**Abstraction** is about hiding unnecessary implementation details and exposing only what's essential to the user. In Python, we achieve this using **Abstract Base Classes (ABCs)** that define a "contract" - subclasses must implement the abstract methods, but each can do so in their own way.

### üéØ Real-world Analogy:
Think of a car's steering wheel. You know *what* it does (turns the car), but you don't need to know *how* it works (the complex mechanics underneath). The steering wheel is the "abstract interface" to the car's turning system.
"""

# First, let's import the necessary tools
from abc import ABC, abstractmethod

"""## üß™ Hands-On Lab: The Payment System

**Goal:** Define a `PaymentMethod` abstract base class that specifies a contract, then implement concrete payment classes that follow it.

**File:** We'll create our payment system right here in this Colab notebook.

### üîß Step 1: Create the Abstract Base Class

We'll define a `PaymentMethod` class that inherits from `ABC` and declares an abstract method `pay()`. This creates our "contract" - any concrete payment method MUST implement a `pay()` method.
"""

# PART 1: The Abstract Blueprint
class PaymentMethod(ABC):

    @abstractmethod
    def pay(self, amount):
        """Process a payment for the given amount."""
        pass

    @abstractmethod
    def refund(self, amount):
        """Process a refund for the given amount."""
        pass

# Try to instantiate the abstract class (this will fail!)
try:
    payment = PaymentMethod()
    print("Created abstract payment method")
except TypeError as e:
    print(f"‚ùå Error: {e}")
    print("This demonstrates that you cannot instantiate an abstract class!")

"""**üìù Explanation:**
- `@abstractmethod` decorator marks methods that MUST be implemented by subclasses
- `PaymentMethod` defines what payment classes should do (the interface), not how they do it
- Trying to create a `PaymentMethod` object directly raises a `TypeError` - enforcing the contract

### üîß Step 2: Create Concrete Payment Classes

Now we'll create specific payment methods that inherit from `PaymentMethod` and provide actual implementations for the abstract methods.
"""

# PART 2: Concrete Payment Classes
class CreditCard(PaymentMethod):
    def __init__(self, card_number, card_holder):
        self.card_number = card_number
        self.card_holder = card_holder
        self.transactions = []

    def pay(self, amount):
        # Simulate credit card payment processing
        transaction_id = f"CC_{len(self.transactions) + 1:04d}"
        self.transactions.append({"type": "payment", "amount": amount, "id": transaction_id})
        print(f"üí≥ Paid ${amount:.2f} using Credit Card ({self.card_holder})")
        return transaction_id

    def refund(self, amount):
        # Simulate credit card refund
        transaction_id = f"CC_REF_{len(self.transactions) + 1:04d}"
        self.transactions.append({"type": "refund", "amount": amount, "id": transaction_id})
        print(f"üí≥ Refunded ${amount:.2f} to Credit Card ({self.card_holder})")
        return transaction_id

class PayPal(PaymentMethod):
    def __init__(self, email):
        self.email = email
        self.transaction_history = []

    def pay(self, amount):
        # Simulate PayPal payment
        transaction_id = f"PP_{len(self.transaction_history) + 1:04d}"
        self.transaction_history.append({"action": "payment", "amount": amount})
        print(f"üìß Paid ${amount:.2f} using PayPal ({self.email})")
        return transaction_id

    def refund(self, amount):
        # Simulate PayPal refund
        transaction_id = f"PP_REF_{len(self.transaction_history) + 1:04d}"
        self.transaction_history.append({"action": "refund", "amount": amount})
        print(f"üìß Refunded ${amount:.2f} to PayPal ({self.email})")
        return transaction_id

class Cash(PaymentMethod):
    def __init__(self):
        self.cash_received = 0
        self.cash_refunded = 0

    def pay(self, amount):
        # Simulate cash payment
        self.cash_received += amount
        print(f"üíµ Paid ${amount:.2f} in cash (Transaction completed)")
        return f"CASH_{int(self.cash_received)}"

    def refund(self, amount):
        # Simulate cash refund
        self.cash_refunded += amount
        print(f"üíµ Refunded ${amount:.2f} in cash")
        return f"CASH_REF_{int(self.cash_refunded)}"

"""**üìù Explanation:**
- Each concrete class (`CreditCard`, `PayPal`, `Cash`) provides its own implementation of `pay()` and `refund()`
- The implementations are different but follow the same interface
- This demonstrates how abstraction allows different payment methods to work through a common interface

### üîß Step 3: Test the Payment System

Let's create different payment methods and process payments through them, demonstrating polymorphism and the power of the abstract interface.
"""

# PART 3: Testing the Payment System
print("=== Payment System Test ===")

# Create different payment methods
payment_methods = [
    CreditCard("1234-5678-9012-3456", "John Doe"),
    PayPal("john.doe@example.com"),
    Cash()
]

# Process payments using the common interface
amounts = [100.50, 75.25, 200.00]

print("\n--- Processing Payments ---")
for i, method in enumerate(payment_methods):
    transaction_id = method.pay(amounts[i])
    print(f"Transaction ID: {transaction_id}")
    print("---")

# Process refunds
print("\n--- Processing Refunds ---")
refund_amounts = [25.00, 10.50, 50.00]
for i, method in enumerate(payment_methods):
    refund_id = method.refund(refund_amounts[i])
    print(f"Refund ID: {refund_id}")
    print("---")

# Demonstrate that we can't create incomplete payment methods
print("\n--- Testing Contract Enforcement ---")
class IncompletePayment(PaymentMethod):
    def pay(self, amount):
        print("Paying...")

try:
    incomplete = IncompletePayment()
    print("Created incomplete payment method")
except TypeError as e:
    print(f"‚ùå Error: {e}")
    print("The abstract class enforces the contract - all methods must be implemented!")

"""## üöÄ Challenge / Bonus Features

Let's extend our payment system with advanced features mentioned in the challenge.
"""

# CHALLENGE: Enhanced Payment System
class EnhancedCreditCard(CreditCard):
    def __init__(self, card_number, card_holder, currency="USD"):
        super().__init__(card_number, card_holder)
        self.currency = currency

    def pay(self, amount):
        if amount <= 0:
            raise ValueError("üí∞ Payment amount must be positive!")

        transaction_id = super().pay(amount)
        print(f"Currency: {self.currency}")
        return transaction_id

    def refund(self, amount):
        if amount <= 0:
            raise ValueError("üí∞ Refund amount must be positive!")

        transaction_id = super().refund(amount)
        print(f"Currency: {self.currency}")
        return transaction_id

# Test the enhanced system with validation
print("\n=== Enhanced Payment System Test ===")

enhanced_cc = EnhancedCreditCard("9876-5432-1098-7654", "Jane Smith", "EUR")

try:
    # This should work
    enhanced_cc.pay(150.75)
    enhanced_cc.refund(25.00)

    # These should fail with validation errors
    print("\n--- Testing Validation ---")
    enhanced_cc.pay(-50.00)  # Should raise ValueError
except ValueError as e:
    print(f"Validation Error: {e}")

# Test currency support
print("\n--- Multi-Currency Support ---")
currencies = ["USD", "EUR", "GBP", "JPY"]
for currency in currencies:
    method = EnhancedCreditCard("0000-0000-0000-0000", "Test User", currency)
    method.pay(100.00)

# Comprehensive Payment System Demo
print("=== Comprehensive Payment System Demo ===")

class PaymentProcessor:
    def __init__(self):
        self.available_methods = []

    def add_method(self, payment_method):
        if isinstance(payment_method, PaymentMethod):
            self.available_methods.append(payment_method)
            print(f"‚úÖ Added payment method: {payment_method.__class__.__name__}")
        else:
            print("‚ùå Error: Only PaymentMethod subclasses can be added!")

    def process_payment(self, amount, method_index):
        if 0 <= method_index < len(self.available_methods):
            try:
                return self.available_methods[method_index].pay(amount)
            except ValueError as e:
                print(f"Payment failed: {e}")
                return None
        else:
            print("‚ùå Invalid payment method selection!")
            return None

    def process_refund(self, amount, method_index):
        if 0 <= method_index < len(self.available_methods):
            try:
                return self.available_methods[method_index].refund(amount)
            except ValueError as e:
                print(f"Refund failed: {e}")
                return None
        else:
            print("‚ùå Invalid payment method selection!")
            return None

# Create and test the complete system
processor = PaymentProcessor()

# Add payment methods
processor.add_method(CreditCard("4111-1111-1111-1111", "Alice Johnson"))
processor.add_method(PayPal("alice@example.com"))
processor.add_method(Cash())
processor.add_method(EnhancedCreditCard("5222-2222-2222-2222", "Bob Brown", "GBP"))

# Test the processor
print("\n--- Processing Transactions ---")
transactions = [
    (150.00, 0),  # Credit card payment
    (75.50, 1),   # PayPal payment
    (200.00, 2),  # Cash payment
    (125.25, 3),  # Enhanced credit card (GBP)
]

for amount, method_idx in transactions:
    print(f"\nProcessing ${amount} payment...")
    transaction_id = processor.process_payment(amount, method_idx)
    if transaction_id:
        print(f"Transaction successful! ID: {transaction_id}")

# Test refunds
print("\n--- Processing Refunds ---")
refunds = [(25.00, 0), (15.50, 1), (50.00, 3)]
for amount, method_idx in refunds:
    print(f"\nProcessing ${amount} refund...")
    refund_id = processor.process_refund(amount, method_idx)
    if refund_id:
        print(f"Refund successful! ID: {refund_id}")

# Test error cases
print("\n--- Testing Error Cases ---")
processor.process_payment(-100.00, 3)  # Negative amount
processor.process_payment(100.00, 99)  # Invalid method index

"""## üìö Abstraction Summary

### üéØ What We Learned:

1.  **Abstract Base Classes (ABCs):** Create contracts using `ABC` and `@abstractmethod`
2.  **Enforcement:** Python prevents instantiation of incomplete abstract classes
3.  **Polymorphism:** Different classes can implement the same interface differently
4.  **Validation:** Add input validation to ensure data integrity
5.  **Extensibility:** Easy to add new payment methods without breaking existing code

### üîë Key Concepts:

- **Abstraction:** Hiding complex implementation details
- **Interface:** The set of methods that a class must implement
- **Contract:** The agreement between abstract class and concrete implementations
- **Liskov Substitution:** Concrete classes should be usable wherever the abstract class is expected

### üí° Real-world Applications:

- Payment processing systems
- Database connectors (same interface for different databases)
- File format handlers (read/write different formats with same methods)
- Plugin systems where third parties can add new functionality

### üöÄ Best Practices:

1.  Keep abstract methods focused and minimal
2.  Provide clear documentation for abstract methods
3.  Use meaningful method names in the interface
4.  Add validation in concrete implementations
5.  Consider using abstract properties (`@abstractproperty`) when needed

### ‚úÖ Completion Checklist:

- [x] Created abstract `PaymentMethod` class with `pay()` and `refund()` methods
- [x] Implemented `CreditCard`, `PayPal`, and `Cash` concrete classes
- [x] Tested polymorphism with different payment methods
- [x] Added validation for negative amounts
- [x] Implemented multi-currency support
- [x] Created a payment processor that works with any `PaymentMethod`
- [x] Tested error handling and edge cases

This abstraction lab demonstrates how to create flexible, extensible systems that can grow with your application's needs!

## 6. üìä Class Attributes vs Instance Attributes

*   **Instance Attributes:** Unique to each object (`self.name`)
*   **Class Attributes:** Shared by all objects of a class (`Species.scientific_name`)
"""

# Class vs Instance Attributes
class Dog:
    # Class attribute - shared by all dogs
    species = "Canis familiaris"
    count = 0

    def __init__(self, name, breed):
        # Instance attributes - unique to each dog
        self.name = name
        self.breed = breed
        Dog.count += 1  # Modify class attribute

    def describe(self):
        return f"{self.name} is a {self.breed} ({self.species})"

# Create some dogs
dog1 = Dog("Buddy", "Golden Retriever")
dog2 = Dog("Max", "Poodle")
dog3 = Dog("Bella", "Beagle")

print(dog1.describe())
print(dog2.describe())
print(dog3.describe())

# All share the same class attribute
print(f"\nAll dogs are: {Dog.species}")
print(f"Total dogs created: {Dog.count}")

# Instance vs class attribute access
print(f"\nBuddy's name (instance): {dog1.name}")
print(f"Buddy's species (class): {dog1.species}")

"""## 7. üé≠ Modifying & Deleting Object Properties

Python objects are dynamic - you can modify, add, or delete attributes after creation!
"""

# Dynamic Object Properties
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Create a person
person = Person("Alice", 30)
print(f"Original: {person.name}, {person.age}")

# Modify existing attribute
person.age = 31
print(f"After modification: {person.name}, {person.age}")

# Add new attribute
person.email = "alice@example.com"
print(f"With new attribute: {person.email}")

# Delete attribute
del person.age
# print(person.age)  # This would now cause an error

# Safe attribute access
current_age = getattr(person, "age", "Age not set")
print(f"Current age: {current_age}")

# Check if attribute exists
if hasattr(person, "email"):
    print(f"Email exists: {person.email}")

"""## 8. üîí Python Naming Conventions & Privacy

Python uses naming conventions rather than strict access control:
"""

# Naming Conventions Example
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner          # Public
        self._balance = balance      # Protected (convention)
        self.__pin = "1234"          # Private (name mangling)

    def show_balance(self):
        return f"Balance: ${self._balance}"

# Create account
account = BankAccount("Alice", 1000)

# Public - accessible
print(f"Owner: {account.owner}")

# Protected - accessible but shouldn't be used directly
print(f"Balance (protected): {account._balance}")

# Private - not directly accessible
# print(account.__pin)  # This would cause an error

# Access through name mangling (not recommended)
print(f"PIN (via mangling): {account._BankAccount__pin}")

# Proper way to access protected data
print(account.show_balance())

"""## ü¶Å Mega Hands-On Lab: The Animal Class

**Goal:** Apply all core OOP concepts‚Äî**Encapsulation, Inheritance, Polymorphism, and Abstraction**‚Äîby creating a complete zoo system. This lab will also reinforce class attributes and naming conventions.

**File:** We'll create our zoo system right here in this Colab notebook.
"""

# First, let's import the necessary modules
from abc import ABC, abstractmethod
import random

"""## üî∑ PART 1: The Abstract Blueprint (Abstraction)

**Concept:** We'll start by defining a "contract" using an Abstract Base Class. We know every animal needs to `eat` and `make_sound`, but we don't know *how* yet. This is perfect for abstraction.

### üìã Instructions:
1. Import `ABC` and `abstractmethod` from the `abc` module
2. Define a class named `Animal` that inherits from `ABC`
3. In `__init__`, accept `name` and `species` and create instance attributes
4. Define a class attribute `zoo_name = "The Python Zoo"`
5. Declare abstract methods `make_sound()` and `eat()` with `@abstractmethod`
"""

# PART 1: The Abstract Blueprint
class Animal(ABC):
    # Class Attribute - shared by ALL instances
    zoo_name = "üêç The Python Zoo"

    def __init__(self, name, species):
        # Instance Attributes - unique to each object
        self.name = name
        self.species = species

    @abstractmethod
    def make_sound(self):
        """Every animal must be able to make a sound"""
        pass

    @abstractmethod
    def eat(self):
        """Every animal must be able to eat"""
        pass

    # A concrete method that all subclasses inherit
    def sleep(self):
        print(f"üò¥ {self.name} is sleeping peacefully...")

# Test that we can't instantiate the abstract class
print("=== Testing Abstract Class Enforcement ===")
try:
    abstract_animal = Animal("Test", "Test")
    print("Created abstract animal (this shouldn't happen!)")
except TypeError as e:
    print(f"‚úÖ Correctly prevented: {e}")

"""**üìù Explanation:**
- `Animal` is now an **abstract base class** - it defines what animals should do, not how
- The `@abstractmethod` decorator ensures subclasses MUST implement these methods
- `zoo_name` is a **class attribute** - shared by all animal instances
- We can include concrete methods like `sleep()` that all subclasses inherit

## üë®‚Äçüë©‚Äçüëß‚Äçüë¶ PART 2: Creating Concrete Classes (Inheritance)

**Concept:** Now we'll create specific animal types that inherit from the `Animal` parent class. Each will provide its own implementation of the abstract methods.

### üìã Instructions:
1. Create `Lion` class that inherits from `Animal`
2. Use `super().__init__(name, species="Lion")` in its `__init__`
3. Implement `make_sound()` to print "Roar!"
4. Create `Monkey` class that inherits from `Animal`
5. Use `super().__init__(name, species="Monkey")`
6. Implement `make_sound()` and `eat()` methods
7. Create `Zookeeper` class (does NOT inherit from Animal)
8. Add protected and private attributes to Zookeeper
"""

# PART 2: Concrete Animal Classes
class Lion(Animal):
    def __init__(self, name):
        # Call parent's __init__ with species set to "Lion"
        super().__init__(name, species="Lion")
        self.mane_color = "golden"  # Lion-specific attribute

    def make_sound(self):
        return "ü¶Å ROAR!!!"

    def eat(self):
        return "devours a large piece of meat ü•©"

    # Lion-specific method
    def hunt(self):
        return f"{self.name} goes hunting in the savannah"

class Monkey(Animal):
    def __init__(self, name):
        super().__init__(name, species="Monkey")
        self.bananas_eaten = 0  # Monkey-specific attribute

    def make_sound(self):
        return "üêµ Ooh ooh oah oah!"

    def eat(self):
        self.bananas_eaten += 1
        return f"eats banana #{self.bananas_eaten} üçå"

    # Monkey-specific method
    def climb(self):
        return f"{self.name} climbs up a tree rapidly"

class Penguin(Animal):
    def __init__(self, name):
        super().__init__(name, species="Penguin")
        self.fish_eaten = 0

    def make_sound(self):
        return "üêß Noot noot!"

    def eat(self):
        self.fish_eaten += 1
        return f"eats fish #{self.fish_eaten} üêü"

    # Penguin-specific method
    def slide(self):
        return f"{self.name} slides happily on its belly!"

# Zookeeper Class (does NOT inherit from Animal)
class Zookeeper:
    def __init__(self, name):
        self.name = name
        self._employee_id = random.randint(1000, 9999)  # Protected attribute
        self.__salary = 45000  # Private attribute (name mangling)
        self.animals_fed = 0

    def feed_animal(self, animal):
        """Feed a single animal"""
        print(f"üßë‚Äçüç≥ {self.name} is feeding {animal.name}...")
        print(f"   {animal.name} {animal.eat()}")
        self.animals_fed += 1

    def feed_animals(self, animals_list):
        """Feed multiple animals (demonstrates polymorphism)"""
        print(f"\n{self.name} is doing the feeding rounds!")
        for animal in animals_list:
            self.feed_animal(animal)

    # Property to access private attribute safely
    @property
    def salary(self):
        return f"${self.__salary:,}"

    def give_raise(self, amount):
        """Method to modify private attribute"""
        self.__salary += amount
        return f"New salary: ${self.__salary:,}"

# Test the concrete classes
print("\n=== Testing Concrete Animals ===")
simba = Lion("Simba")
george = Monkey("George")
pingu = Penguin("Pingu")

print(f"{simba.name}: {simba.make_sound()}")
print(f"{george.name}: {george.make_sound()}")
print(f"{pingu.name}: {pingu.make_sound()}")

# Test inheritance
print(f"\nAll animals belong to: {simba.zoo_name}")

"""## #Ô∏è‚É£ PART 3: Bringing the Zoo to Life (Polymorphism & Class Attributes)

**Concept:** The power of polymorphism is that we can treat different objects uniformly. We can ask any `Animal` to `make_sound()`, and it will respond correctly based on its specific class.

### üìã Instructions:
1. Create a list of animals with instances of different classes
2. Create a Zookeeper instance
3. Demonstrate polymorphism by looping through animals and calling methods
4. Show how class attributes work across different instances
"""

# PART 3: Running the Zoo
print("=== üé™ The Python Zoo is Open! ===")

# Create our zoo population
animals = [
    Lion("Leo"),
    Monkey("Momo"),
    Penguin("Pingu"),
    Lion("Nala"),
    Monkey("Koko")
]

# Create our zookeeper
zookeeper = Zookeeper("Alex")

# Demonstrate POLYMORPHISM
print("\n=== Morning Roll Call (Polymorphism Demo) ===")
for animal in animals:
    sound = animal.make_sound()
    print(f"{animal.name} the {animal.species}: {sound}")

# Demonstrate CLASS ATTRIBUTES
print("\n=== Class Attributes Demo ===")
print(f"All animals live at: {Animal.zoo_name}")
print(f"Leo knows he's at: {animals[0].zoo_name}")
print(f"Pingu knows he's at: {animals[2].zoo_name}")
print(f"The Lion class knows: {Lion.zoo_name}")

# Show they're all the same object in memory
print(f"\nSame object? {animals[0].zoo_name is Animal.zoo_name}")

# Demonstrate feeding (more polymorphism)
print("\n" + "="*50)
zookeeper.feed_animals(animals)

# Show zookeeper stats
print(f"\n{zookeeper.name} has fed {zookeeper.animals_fed} animals today!")

"""## üöÄ CHALLENGE / Bonus Features (Applying All Concepts)

Let's implement all the bonus features to demonstrate advanced OOP concepts.
"""

# CHALLENGE: Advanced Features
print("\n=== üöÄ Challenge/Bonus Features ===")

# 1. Modify an Object Dynamically
print("\n1. üé≠ Dynamic Object Modification")
leo = animals[0]  # Get the first animal (Leo the Lion)
leo.favorite_toy = "Big Red Ball"  # Add new attribute dynamically
leo.mane_color = "magnificent"  # Modify existing attribute

print(f"{leo.name}'s favorite toy: {leo.favorite_toy}")
print(f"{leo.name}'s mane is {leo.mane_color}")

# 2. Naming Conventions & Privacy
print("\n2. üîí Naming Conventions & Privacy")
print(f"Zookeeper name (public): {zookeeper.name}")
print(f"Employee ID (protected): {zookeeper._employee_id}")
print(f"Salary via property: {zookeeper.salary}")

# Try to access private attribute directly (will fail)
try:
    print(f"Private salary (direct): {zookeeper.__salary}")
except AttributeError as e:
    print(f"‚ùå Cannot access private directly: {e}")

# Access via name mangling (not recommended, but possible)
print(f"Private salary (mangled): {zookeeper._Zookeeper__salary}")

# 3. Give zookeeper a raise using the public method
print(f"\nBefore raise: {zookeeper.salary}")
new_salary = zookeeper.give_raise(5000)
print(f"After raise: {new_salary}")

# 4. Extend with a New Animal Class
print("\n3. üêò Extending with New Animals")
class Elephant(Animal):
    def __init__(self, name):
        super().__init__(name, species="Elephant")
        self.water_sprayed = 0

    def make_sound(self):
        return "üêò Trumpet!!!"

    def eat(self):
        return "eats 200kg of vegetation üåø"

    def spray_water(self):
        self.water_sprayed += 1
        return f"{self.name} sprays water with its trunk! üí¶"

# Add elephant to our zoo
dumbo = Elephant("Dumbo")
animals.append(dumbo)

print(f"New arrival: {dumbo.name}!")
print(f"{dumbo.name}: {dumbo.make_sound()}")
print(f"{dumbo.name}: {dumbo.spray_water()}")

# 5. Re-run the zoo with new animal
print("\n=== Updated Zoo Activities ===")
zookeeper.feed_animals(animals)  # Now includes the elephant!

# 6. Specialized feeding for different animals
print("\n4. üéØ Specialized Feeding Demo")
def specialized_feeding(animal):
    """Demonstrate how we can handle different animals specially"""
    if isinstance(animal, Lion):
        print(f"üßë‚Äçüç≥ Giving extra meat to {animal.name} the lion!")
    elif isinstance(animal, Monkey):
        print(f"üßë‚Äçüç≥ Giving bananas to {animal.name} the monkey!")
    elif isinstance(animal, Penguin):
        print(f"üßë‚Äçüç≥ Giving fish to {animal.name} the penguin!")
    elif isinstance(animal, Elephant):
        print(f"üßë‚Äçüç≥ Giving massive vegetation to {animal.name} the elephant!")
    animal.eat()

print("\n=== Specialized Feeding Time ===")
for animal in animals:
    specialized_feeding(animal)

# 7. Show class hierarchy
print("\n5. üìä Class Hierarchy Info")
print(f"Animal class: {Animal.__name__}")
print(f"Lion MRO: {Lion.__mro__}")  # Method Resolution Order
print(f"Is Leo an Animal? {isinstance(leo, Animal)}")
print(f"Is Alex a Zookeeper? {isinstance(zookeeper, Zookeeper)}")
print(f"Is Alex an Animal? {isinstance(zookeeper, Animal)}")

# Comprehensive Zoo Management System
print("=== üè∞ Comprehensive Zoo Management System ===")

class Zoo:
    def __init__(self, name):
        self.name = name
        self.animals = []
        self.zookeepers = []
        self.visitors_today = 0

    def add_animal(self, animal):
        if isinstance(animal, Animal):
            self.animals.append(animal)
            print(f"‚úÖ Added {animal.name} the {animal.species} to {self.name}")
        else:
            print("‚ùå Can only add Animal instances!")

    def add_zookeeper(self, zookeeper):
        self.zookeepers.append(zookeeper)
        print(f"‚úÖ Hired {zookeeper.name} as a zookeeper")

    def open_zoo(self):
        print(f"\nüé™ {self.name} is now OPEN!")
        print(f"Animals in residence: {len(self.animals)}")
        print(f"Zookeepers on duty: {len(self.zookeepers)}")

        # Morning routines
        self.morning_roll_call()
        self.feeding_time()

        # Visitors arrive
        self.visitors_today = random.randint(50, 200)
        print(f"\nüë• {self.visitors_today} visitors enjoying the zoo today!")

    def morning_roll_call(self):
        print("\n=== Morning Roll Call ===")
        for animal in self.animals:
            print(f"{animal.name} the {animal.species}: {animal.make_sound()}")

    def feeding_time(self):
        print("\n=== Feeding Time ===")
        if self.zookeepers:
            for zookeeper in self.zookeepers:
                zookeeper.feed_animals(self.animals)
        else:
            print("‚ùå No zookeepers available for feeding!")

    def close_zoo(self):
        print(f"\nüåô {self.name} is now CLOSED")
        print(f"Total visitors today: {self.visitors_today}")
        print("All animals are going to sleep...")
        for animal in self.animals:
            animal.sleep()

# Create and run our complete zoo
python_zoo = Zoo("The Amazing Python Zoo")

# Add animals
python_zoo.add_animal(Lion("Simba"))
python_zoo.add_animal(Monkey("George"))
python_zoo.add_animal(Penguin("Pingu"))
python_zoo.add_animal(Elephant("Dumbo"))

# Add zookeepers
python_zoo.add_zookeeper(Zookeeper("Alex"))
python_zoo.add_zookeeper(Zookeeper("Taylor"))

# Run a day at the zoo
python_zoo.open_zoo()
python_zoo.close_zoo()

"""## üìö Animal Zoo Lab Summary

### üéØ What We Implemented:

1.  **üß© Abstraction:** Created `Animal` abstract base class with required methods
2.  **üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Inheritance:** Built `Lion`, `Monkey`, `Penguin`, `Elephant` subclasses
3.  **#Ô∏è‚É£ Polymorphism:** Treated different animals uniformly through common interface
4.  **üìä Class Attributes:** Used `zoo_name` shared across all instances
5.  **üîí Encapsulation:** Used protected (`_id`) and private (`__salary`) attributes
6.  **üé≠ Dynamic Objects:** Added attributes to objects after creation

### üîë OOP Concepts Demonstrated:

- **Abstract Methods:** Enforcement of required behaviors
- **Method Overriding:** Each animal implements methods differently
- **`super()`:** Calling parent class methods
- **`isinstance()`:** Checking object types
- **Property Decorators:** Controlled access to private attributes
- **Dynamic Nature:** Python's flexibility with object attributes

### üí° Real-world Applications:

- Game character systems
- Simulation software
- UI framework components
- Plugin architectures
- Any system with multiple related but different entities

### ‚úÖ Completion Checklist:

- [x] Abstract `Animal` class with `make_sound()` and `eat()` methods
- [x] Multiple concrete animal classes with unique implementations
- [x] Class attribute shared across all instances
- [x] Polymorphism demonstrated through uniform method calls
- [x] Protected and private attributes with proper access
- [x] Dynamic attribute modification
- [x] Complete zoo management system
- [x] Comprehensive error handling and validation

This lab demonstrates how all four pillars of OOP work together to create flexible, maintainable, and extensible systems!
"""