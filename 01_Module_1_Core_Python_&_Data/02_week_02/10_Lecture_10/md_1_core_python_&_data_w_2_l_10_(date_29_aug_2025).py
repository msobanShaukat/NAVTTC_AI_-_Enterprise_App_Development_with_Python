# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#2_L#10_(Date:29-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j-ranW0fsZ7r5QQNaTGvDLXLPYPLrVFn

# üß† Module 1: Core Python & Data - Week 2 Lecture 10
**Date:** 29/08/2025  
**Documented by:** Muhammad Soban Shaukat

## üèóÔ∏è A New Way of Thinking: Introduction to Object-Oriented Programming (OOP)

We've mastered functions for reusable code. But as programs grow, we need a better way to manage complexity. Welcome to **Object-Oriented Programming (OOP)** ‚Äì the foundation of modern software. It's not just new syntax; it's a new way to think about problems.

---

Yesterday's focus was **Encapsulation** (bundling data & methods). But OOP is built on three other powerful ideas. Let's explore them briefly.

## 2. üë®‚Äçüë©‚Äçüëß‚Äçüë¶ The Power of Inheritance

Inheritance allows a new class (**child**) to reuse and extend the functionality of an existing class (**parent**). This promotes code reusability and a logical hierarchy.

*   **Syntax:** `class ChildClass(ParentClass):`
*   **`super()`:** Function used to call methods from the parent class.
"""

# Inheritance Example: Animals
class Animal:
    def __init__(self, name):
        self.name = name

    def eat(self):
        print(f"{self.name} is eating.")

    def sleep(self):
        print(f"{self.name} is sleeping.")

# Dog inherits from Animal
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Call parent's __init__
        self.breed = breed      # New attribute specific to Dog

    # New method specific to Dog
    def bark(self):
        print(f"{self.name} says: Woof!")

    # Overriding parent's method
    def eat(self):
        print(f"{self.name} the {self.breed} wolfs down its food!")

# Cat also inherits from Animal
class Cat(Animal):
    def meow(self):
        print(f"{self.name} says: Meow!")

# Create objects
my_dog = Dog("Rex", "Labrador")
my_cat = Cat("Whiskers")

# Inherited methods
my_dog.eat()    # Uses overridden version
my_cat.eat()    # Uses parent's version
my_dog.sleep()  # Uses inherited method
my_cat.sleep()  # Uses inherited method

# Child-specific methods
my_dog.bark()
my_cat.meow()

print(f"{my_dog.name} is a {my_dog.breed}.")

"""## 3. #Ô∏è‚É£ The Power of Polymorphism

Polymorphism means "many forms". It allows objects of different classes to be treated as objects of a common superclass. The same method call can behave differently depending on the object's class.
"""

# Polymorphism in Action
def animal_sounds(animals):
    for animal in animals:
        animal.make_sound() # We expect all animals to have this method

# Different classes with the same method name
class Bird:
    def make_sound(self):
        print("Chirp chirp!")

class Cow:
    def make_sound(self):
        print("Moo!")

# Create a list of different objects
farm_animals = [Bird(), Cow(), Dog("Buddy", "Beagle")]

# The same function works for all!
print("=== On the Farm ===")
animal_sounds(farm_animals)

"""## 4. üî∑ Hands-On Lab: The Shape Class

**Goal:** Create a hierarchy of shapes where each shape can calculate its area, demonstrating inheritance and polymorphism.

**Step-by-Step Instructions:**
### Part 1: The Blueprint (Base Class)
"""

# Base Class: Shape
class Shape:
    def area(self):
        pass  # Placeholder - to be overridden by child classes

    # A common method for all shapes
    def describe(self):
        print("I am a shape.")

"""### Part 2: Adding Behaviors (Child Classes)"""

# Child Class: Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    # Override the area method
    def area(self):
        return 3.14159 * self.radius ** 2

    # Override describe method
    def describe(self):
        print(f"I am a circle with radius {self.radius}.")

# Child Class: Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    # Override the area method
    def area(self):
        return self.width * self.height

    # Override describe method
    def describe(self):
        print(f"I am a rectangle {self.width}x{self.height}.")

"""### Part 3: Testing Your Classes"""

# Create different shapes
shapes = [
    Circle(5),
    Rectangle(4, 6),
    Circle(3),
    Rectangle(2, 8)
]

# Demonstrate polymorphism
print("=== Shape Areas ===")
total_area = 0
for shape in shapes:
    shape.describe()
    area = shape.area()
    print(f"My area is: {area:.2f}")
    total_area += area
    print("---")

print(f"Total area of all shapes: {total_area:.2f}")

"""### üß† Challenge: Add a Triangle Class"""

# Challenge: Triangle Class
class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

    def describe(self):
        print(f"I am a triangle with base {self.base} and height {self.height}.")

# Test the Triangle
shapes.append(Triangle(6, 4))
print(f"Triangle area: {shapes[-1].area()}")

"""## 4. üì∫ The Power of Abstraction

**Abstraction** is about hiding unnecessary implementation details and exposing only what's essential to the user. In Python, we achieve this using **Abstract Base Classes (ABCs)** that define a "contract" - subclasses must implement the abstract methods, but each can do so in their own way.

### üéØ Real-world Analogy:
Think of a car's steering wheel. You know *what* it does (turns the car), but you don't need to know *how* it works (the complex mechanics underneath). The steering wheel is the "abstract interface" to the car's turning system.
"""

# First, let's import the necessary tools
from abc import ABC, abstractmethod

"""## üß™ Hands-On Lab: The Payment System

**Goal:** Define a `PaymentMethod` abstract base class that specifies a contract, then implement concrete payment classes that follow it.

**File:** We'll create our payment system right here in this Colab notebook.

### üîß Step 1: Create the Abstract Base Class

We'll define a `PaymentMethod` class that inherits from `ABC` and declares an abstract method `pay()`. This creates our "contract" - any concrete payment method MUST implement a `pay()` method.
"""

# PART 1: The Abstract Blueprint
class PaymentMethod(ABC):

    @abstractmethod
    def pay(self, amount):
        """Process a payment for the given amount."""
        pass

    @abstractmethod
    def refund(self, amount):
        """Process a refund for the given amount."""
        pass

# Try to instantiate the abstract class (this will fail!)
try:
    payment = PaymentMethod()
    print("Created abstract payment method")
except TypeError as e:
    print(f"‚ùå Error: {e}")
    print("This demonstrates that you cannot instantiate an abstract class!")