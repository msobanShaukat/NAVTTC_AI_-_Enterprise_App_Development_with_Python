# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#1_L#7_(Date:25-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aC_kuqyaRrtiRyyEePgM8bSytH2yy7Zj

# 🔁 Module 1: Core Python & Data - Week 1 Lecture 7
**Date:** 25/08/2025  
**Documented By:** Muhammad Soban Shaukat

## 📋 The Power of Repetition: For and While Loops

We've made our programs smart with conditions. Now, let's make them **powerful** and **efficient** 💪 with **loops**! Loops automate repetitive tasks, allowing us to process massive amounts of data, control games, and handle user input with elegant, concise code.

## 📋 Today's Agenda

1.  **🔄 The `for` Loop & Pythonic Iteration**
    *   Automating Tasks & The `for` Loop
    *   The `range()` Function
    *   `enumerate()` & `zip()` Functions
    *   Interactive Exercises

2.  **⚡ The `while` Loop & Controlling Flow**
    *   The Conditional `while` Loop
    *   `break` & `continue` Statements
    *   Interactive Exercises

3.  **🚀 Advanced Loop Patterns & The Lab**
    *   The `else` Block in Loops
    *   `for` vs. `while`: Choosing the Right Tool
    *   **🧪 Hands-On Lab:** Interactive Data Aggregator

## 1. 🔄 The `for` Loop & Pythonic Iteration

### The "Why": Automating Repetitive Tasks
Imagine printing 100 names. Writing 100 `print()` statements is tedious. A **loop** lets you define a task once and repeat it for every item in a collection (like a list, string, or dictionary). This is the essence of programming power.

### The `for` Loop: Python's "For Each" Powerhouse
The `for` loop in Python is used to iterate over items in any **sequence** (list, tuple, string, etc.). The syntax is clean and reads almost like English: "**for** each item **in** this collection, do this."

**Syntax:** `for variable_name in sequence:`
"""

# Looping over a list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(f"Current fruit is: {fruit} 🍎")

print("Loop finished! 🎯")

# Looping over a string
for char in "Python":
    print(char, end="-") # The 'end' parameter changes the ending character
print("\n") # Print a newline at the end

# Looping over a dictionary
user = {"name": "Alice", "id": 123, "is_active": True}
print("User details:")
for key, value in user.items(): # .items() returns key-value pairs
    print(f"  {key}: {value}")

"""### The `range()` Function: Looping a Specific Number of Times
What if you don't have a list, but just want to do something 5 times? The `range()` function generates a sequence of numbers for you to loop over.

**Syntax:**
*   `range(stop)` → Generates numbers from `0` to `stop-1`
*   `range(start, stop)` → Generates numbers from `start` to `stop-1`
*   `range(start, stop, step)` → Generates numbers from `start` to `stop-1`, incrementing by `step`
"""

# Loop 5 times (0 to 4)
print("Looping 5 times:")
for i in range(5):
    print(f"Round {i}")

print()

# Loop from 2 to 6 (2, 3, 4, 5, 6)
print("Numbers from 2 to 6:")
for i in range(2, 7):
    print(i)

print()

# Count down from 10 to 1 by 2s (10, 8, 6, 4, 2)
print("Countdown from 10 by 2s:")
for i in range(10, 0, -2):
    print(i)

"""### Looping with an Index: The `enumerate()` Function
Often, you need both the **item** and its **index** (position). The Pythonic way to do this is with `enumerate()`. It returns both the index and the item on each iteration.

**Syntax:** `for index, item in enumerate(sequence):`
"""

fruits = ["apple", "banana", "cherry"]

# The C-style, less Pythonic way (avoid this)
print("Less Pythonic way (range(len)):")
for i in range(len(fruits)):
    print(f"Index {i}: {fruits[i]}")

print()

# The Pythonic way with enumerate() ✅
print("Pythonic way (enumerate):")
for index, fruit in enumerate(fruits): # Tuple unpacking!
    print(f"Index {index}: {fruit}")

print()

# You can even start the index at a different number
print("Starting index at 1:")
for index, fruit in enumerate(fruits, start=1):
    print(f"Item #{index}: {fruit}")

"""### Looping Over Multiple Lists: The `zip()` Function
What if you have two or more related lists? The `zip()` function pairs their items together. It's perfect for processing corresponding data.

**Syntax:** `for item_a, item_b in zip(list_a, list_b):`

**Note:** `zip()` stops at the end of the **shortest** list.
"""

students = ["Alice", "Bob", "Charlie"]
grades = [95, 88, 92]
ids = [101, 102, 103]

print("Student Report:")
for student, grade, student_id in zip(students, grades, ids):
    print(f"ID: {student_id} - {student}: {grade}%")

"""### 🧠 In-Class Exercise: The FizzBuzz Challenge
A classic programming interview question! Loop from 1 to 100:
*   For multiples of **3**, print `"Fizz"` 🫧
*   For multiples of **5**, print `"Buzz"` 🐝
*   For multiples of **both 3 and 5**, print `"FizzBuzz"` 🎉
*   Otherwise, print the number.
"""

# Exercise: FizzBuzz Challenge
print("FizzBuzz Challenge (1 to 100):")

for num in range(1, 101):
    if num % 3 == 0 and num % 5 == 0:
        print("FizzBuzz 🎉")
    elif num % 3 == 0:
        print("Fizz 🫧")
    elif num % 5 == 0:
        print("Buzz 🐝")
    else:
        print(num)

"""## 2. ⚡ The `while` Loop & Controlling Flow

### The `while` Loop: The Conditional Loop
A `while` loop runs **as long as a condition is `True`**. Use it when you don't know how many iterations you'll need in advance (e.g., waiting for valid user input).

**Syntax:** `while condition:`

**⚠️ Danger:** If the condition never becomes `False`, you get an **infinite loop**! Always ensure the loop has a way to end.
"""

# A simple while loop
count = 0
while count < 5:
    print(f"Count is {count}")
    count += 1  # CRITICAL: This updates the condition variable

print("While loop finished! ✅")

# Simulating a process that might take random attempts
print("\nWaiting for a successful task...")
import random
attempts = 0
success = False

while not success:
    attempts += 1
    # Simulate a 20% chance of success each attempt
    if random.random() < 0.2:
        success = True
        print(f"Success! 🎉 It took {attempts} attempts.")
    else:
        print(f"Attempt {attempts} failed. Trying again...")

"""### Controlling Loops: `break` and `continue`
These powerful statements give you fine-grained control inside loops.

*   `break`: Immediately **exits** the innermost loop. Jump to the code *after* the loop.
*   `continue`: Immediately **skips** the rest of the current iteration and jumps back to the top of the loop to start the next one.
"""

# Example of 'break': Find the first number divisible by 7
print("Finding first number divisible by 7:")
numbers = [2, 5, 11, 14, 22, 21]

for num in numbers:
    print(f"Checking {num}...")
    if num % 7 == 0:
        print(f"Found it! {num} is divisible by 7. ✅")
        break # Exit the loop immediately
    print("Not divisible by 7.")

print("Search over.\n")

# Example of 'continue': Process only positive numbers
print("Processing only positive numbers:")
data = [10, 20, -5, 30, -1, 0, 40]

for item in data:
    if item <= 0:
        print(f"Skipping {item} (not positive).")
        continue # Skip the rest of this iteration
    # This code only runs for positive numbers
    result = item * 2
    print(f"Processing {item}: {item} * 2 = {result}")

"""### 🧠 In-Class Exercise: Input Validator
Use a `while` loop to keep asking for a name until the user enters one that is at least 3 characters long.
"""

# Exercise: Input Validator
print("Please enter your name (must be at least 3 characters long).")

while True: # This creates an "infinite" loop
    name = input("Enter your name: ").strip()

    if len(name) >= 3:
        print(f"Welcome, {name}! 👋")
        break # Exit the infinite loop
    else:
        print("❌ Name too short. Please enter at least 3 characters.\n")
        # The loop will continue automatically

"""## 3. 🚀 Advanced Loop Patterns & The Lab

### The `else` Block in Loops: A Unique Python Feature
Python loops can have an `else` clause! The `else` block runs **only if the loop completed normally without hitting a `break` statement**. This is perfect for search operations.

**Logic:** "Run this loop. If you find what you're looking for, `break`. If you finish the entire loop without finding it (`break` never happened), then run the `else` block."
"""

# Use case: Searching for an item
print("Searching for an item in a list:")
my_list = [1, 3, 5, 7, 9]
search_for = 4 # Try changing this to 5

for item in my_list:
    if item == search_for:
        print(f"Found {search_for}! ✅")
        break
else: # This runs only if the loop did NOT break
    print(f"{search_for} was not found in the list. ❌")

print("Search complete.\n")

"""### Choosing the Right Loop: `for` vs. `while`

| Use a `for` loop when... | Use a `while` loop when... |
| :--- | :--- |
| You have a **definite collection** to process (list, string, range). | You are looping based on a **condition**, not a collection. |
| You know **how many times** you need to loop. | You **don't know** how many iterations it will take. |
| *Example: Print all items in a list.* | *Example: Wait for user to type "quit".* |

## 🧪 Hands-On Lab: Interactive Data Aggregator

Let's build a program that lets a user enter numbers, then calculates statistics on them. This combines **loops, lists, conditionals, error handling, and built-in functions**.
We'll build it step-by-step.
"""

# The Complete Interactive Data Aggregator

# PART 1: Setup
numbers = [] # Empty list to store our numbers
print("Welcome to the Data Aggregator! 📊")
print("Enter numbers one by one. Type 'done' when you are finished.\n")

# PARTS 2 & 3: The Input Loop with Validation
while True:
    user_input = input("Enter a number (or 'done'): ").strip().lower()

    # Check if the user wants to quit
    if user_input == 'done':
        break # Exit the input loop

    # PART 3: Try to convert the input to a number
    try:
        num = float(user_input) # Use float to handle decimals
        numbers.append(num) # Add the valid number to our list
        print(f"Added {num} to the list. ✅")
    except ValueError:
        print("❌ Invalid input! Please enter a number or 'done'.")

print("\n" + "="*40)

# PART 4: Calculation and Output
if not numbers: # Check if the list is empty
    print("No numbers were entered. 😴")
else:
    # Perform calculations using built-in functions
    count = len(numbers)
    total_sum = sum(numbers)
    average = total_sum / count
    maximum = max(numbers)
    minimum = min(numbers)

    # Print the results
    print("RESULTS 📈:")
    print(f"  Count: {count}")
    print(f"  Sum: {total_sum}")
    print(f"  Average: {average:.2f}") # :.2f formats to 2 decimal places
    print(f"  Maximum: {maximum}")
    print(f"  Minimum: {minimum}")

    # CHALLENGE: Store in a Dictionary
    analysis_results = {
        "count": count,
        "sum": total_sum,
        "average": average,
        "max": maximum,
        "min": minimum
    }
    print(f"\nResults Dictionary: {analysis_results}")

"""### 🚀 Challenge / Bonus Features
Let's add the advanced features from the slides.
"""

# CHALLENGE: Filtering and Median
if numbers:
    print("\n" + "="*40)
    print("BONUS FEATURES 🚀")

    # Filter for positive numbers only
    positive_numbers = [num for num in numbers if num > 0]
    # [num for num in numbers if num > 0] is a list comprehension!

    if positive_numbers:
        pos_count = len(positive_numbers)
        pos_sum = sum(positive_numbers)
        pos_avg = pos_sum / pos_count
        print(f"\nAnalysis of POSITIVE numbers only ({pos_count} numbers):")
        print(f"  Sum: {pos_sum}, Average: {pos_avg:.2f}")
    else:
        print("\nNo positive numbers were entered.")

    # Calculate Median
    sorted_numbers = sorted(numbers) # Sort the list first
    n = len(sorted_numbers)
    mid_index = n // 2 # Integer division to find the middle

    if n % 2 == 1: # If odd number of elements
        median = sorted_numbers[mid_index]
    else: # If even number of elements
        median = (sorted_numbers[mid_index - 1] + sorted_numbers[mid_index]) / 2

    print(f"  Median: {median}")