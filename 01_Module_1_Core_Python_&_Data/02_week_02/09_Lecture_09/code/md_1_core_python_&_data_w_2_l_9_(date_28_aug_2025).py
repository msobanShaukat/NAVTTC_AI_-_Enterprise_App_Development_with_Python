# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#2_L#9_(Date:28-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rzdJ1cjyq4W8WBPEVmbdriSFjN24Tqbi

# üß† Module 1: Core Python & Data - Week 2 Lecture 9
**Date:** 28/08/2025  
**Documented By:** Muhammad Soban Shaukat

## üèóÔ∏è A New Way of Thinking: Introduction to Object-Oriented Programming (OOP)

We've mastered functions for reusable code. But as programs grow, we need a better way to manage complexity. Welcome to **Object-Oriented Programming (OOP)** ‚Äì the foundation of modern software. It's not just new syntax; it's a new way to think about problems.

## üìã Today's Agenda

1.  **ü§î The "Why" - From Data to Objects**
    *   The Problem with Procedural Code
    *   The Core Idea: Bundling Data & Behavior
    *   The Blueprint and the House (Classes & Objects)
    *   Defining a Class & The `__init__` Constructor
    *   The Magic of `self`
    *   Interactive Exercise: Creating Your First `Dog` Object

2.  **‚öôÔ∏è Bringing Objects to Life with Methods**
    *   What are Methods?
    *   Defining and Calling Methods
    *   How Methods Use `self`
    *   Special Methods: `__str__`
    *   Interactive Exercise: Making the Dog `bark()` and `sit()`

3.  **üß™ Putting It All Together: The Hands-On Lab**
    *   Key Takeaways: Class vs. Object, Attribute vs. Method
    *   The Power of Encapsulation
    *   **Hands-On Lab:** The `Car` Class

## 1. ü§î The "Why" - From Data to Objects

### The Problem with Procedural Code: Managing Complexity
Imagine building a game with characters. Using what we know (dictionaries and functions), it gets messy and error-prone quickly.
"""

# The Problem: Data (dictionaries) and Behavior (functions) are separate.
# This is fragile and hard to manage.

player1 = {"name": "Gandalf", "hp": 100, "mana": 200}
player2 = {"name": "Aragorn", "hp": 150, "stamina": 120}

def cast_spell(player, cost):
    player["mana"] -= cost
    print(f"{player['name']} casts a spell!")

def swing_sword(player, cost):
    player["stamina"] -= cost
    print(f"{player['name']} swings their sword!")

cast_spell(player1, 30) # This works.
# swing_sword(player1, 10) # This would cause an ERROR! Gandalf has no 'stamina'.
# print(player1) # Let's see the state of player1

"""### The Four Pillars of OOP
OOP solves these problems by bundling data and behavior into "objects". It's built on four principles. Today, we focus on the first one:

1.  **üß• Encapsulation:** Bundling data (attributes) and methods into a single object. **(Today's Focus!)**
2.  **üì∫ Abstraction:** Hiding complex details, showing only essentials.
3.  **üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Inheritance:** Creating new classes based on existing ones.
4.  #Ô∏è‚É£ **Polymorphism:** Objects of different classes responding to the same method call in their own way.

### Analogy: The Blueprint and the House üè†

*   A **Class** is like a **blueprint**. It defines the structure (attributes) and capabilities (methods) of something.
    *   *Example:* `class Car:` defines what a car *is* and what it can *do*.
*   An **Object** is the actual **thing** built from the blueprint. It's a unique **instance**.
    *   *Example:* `my_car = Car("Toyota", "Blue")` creates one specific, real car from the `Car` blueprint.

### Defining a Class: The `class` Keyword
We use the `class` keyword. By convention, class names use **PascalCase**.
"""

# Creating a simple blueprint (class)
class Dog:
    pass  # 'pass' is a placeholder for empty code. Our class does nothing yet.

# Let's create an object (instance) from our Dog class.
my_dog = Dog()
print("my_dog is an:", type(my_dog))
print("It's a very simple dog...", my_dog)

"""### The Constructor: `__init__()`
How do we give our dog a name and age when we create it? We use the `__init__` method. It's a special **constructor** method that runs automatically when a new object is created.

*   Methods like `__init__` that start and end with double underscores `__` are called **"dunder" methods** and are special in Python.

### The Magic of `self`
`self` is the most important concept. It refers to the **specific object instance** being created or worked on.

*   When you write `self.name = name`, it means: "For *this specific dog* I'm creating right now, set its `name` attribute to the value that was passed in."
"""

# Let's build a proper Dog blueprint!
class Dog:

    # The initializer/constructor method
    def __init__(self, name, age):
        # We create attributes for the object using 'self'
        self.name = name   # Creates an attribute 'name' for this dog
        self.age = age     # Creates an attribute 'age' for this dog
        print(f"A new dog named {self.name} has been created!")

# Creating two unique Dog OBJECTS from the same Dog CLASS blueprint
dog1 = Dog("Fido", 4)
dog2 = Dog("Lucy", 2)

# Accessing their attributes using dot notation
print(f"{dog1.name} is {dog1.age} years old.")
print(f"{dog2.name} is {dog2.age} years old.")

"""### üß† In-Class Exercise: Modeling a Student

Create a `Student` class.
1.  Its `__init__` method should accept `name` and `student_id`.
2.  Create the attributes `self.name`, `self.student_id`.
3.  Add another attribute `self.courses` and initialize it as an empty list `[]`.
4.  Create two different `Student` objects and print their names and IDs.
"""

# Exercise: Student Class
class Student:
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        self.courses = [] # A list to store courses

# Create Student objects (instances)
student1 = Student("Alice", "S12345")
student2 = Student("Bob", "S67890")

print(f"Student 1: {student1.name} (ID: {student1.student_id})")
print(f"Student 2: {student2.name} (ID: {student2.student_id})")
print("Alice's courses (initially):", student1.courses)

"""## 2. ‚öôÔ∏è Bringing Objects to Life with Methods

### What are Methods?
**Methods** are simply functions that are defined *inside a class*. They define the **behaviors** (actions) an object can perform.

*   The first parameter of every method is **always `self`**. This gives the method access to all the object's attributes (`self.name`, `self.age`, etc.).
"""

# Let's add behaviors to our Dog!
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.is_sitting = False # A new attribute to track state

    # A method to represent a behavior
    def bark(self):
        print(f"{self.name} says: Woof!")

    # A method that changes the object's internal state
    def sit(self):
        print(f"{self.name} is now sitting.")
        self.is_sitting = True # Modify the object's attribute

    def stand(self):
        if self.is_sitting:
            print(f"{self.name} is now standing.")
            self.is_sitting = False
        else:
            print(f"{self.name} is already standing!")

# Create a dog and make it do things!
my_dog = Dog("Rex", 5)

my_dog.bark() # Call the bark method
print(f"Is Rex sitting? {my_dog.is_sitting}")

my_dog.sit()  # Call the sit method
print(f"Is Rex sitting? {my_dog.is_sitting}")

my_dog.stand() # Call the stand method

"""### Special Methods: `__str__()`
What happens if you try to print an object directly? You get a not-very-useful technical description.

The `__str__` method allows you to define a friendly, readable string representation of your object. It's called automatically by functions like `print()`.
"""

# Let's make our objects print nicely!
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f"{self.name} says: Woof!")

    # Define the __str__ method
    def __str__(self):
        return f"Dog(Name: {self.name}, Age: {self.age})"

my_dog = Dog("Rex", 5)
print(my_dog) # Now this prints our custom string! Magic!

"""### üß† In-Class Exercise: Bank Account

Create a `BankAccount` class.
1.  The `__init__` method takes an `owner_name` and an `initial_balance` (default to 0).
2.  Create a `deposit(self, amount)` method that adds to the balance.
3.  Create a `withdraw(self, amount)` method. Subtract from the balance, but **check first** to prevent overdrafting!
4.  Create a `__str__` method that returns a string like `"Account for John Doe: $500"`.
"""

# Exercise: BankAccount Class
class BankAccount:
    def __init__(self, owner_name, initial_balance=0):
        self.owner_name = owner_name
        self.balance = initial_balance

    def deposit(self, amount):
        self.balance += amount
        print(f"Deposited ${amount}. New balance: ${self.balance}")

    def withdraw(self, amount):
        if amount > self.balance:
            print(f"‚ùå Error: Insufficient funds. Your balance is ${self.balance}.")
        else:
            self.balance -= amount
            print(f"Withdrew ${amount}. New balance: ${self.balance}")

    def __str__(self):
        return f"Account for {self.owner_name}: ${self.balance}"

# Test the BankAccount class
alice_account = BankAccount("Alice", 1000)
print(alice_account)

alice_account.deposit(200)
alice_account.withdraw(500)
alice_account.withdraw(1000) # This should fail
print(alice_account)

"""## 3. üß™ Putting It All Together: The Hands-On Lab

### Key Takeaways

| Concept | Description | Example |
| :--- | :--- | :--- |
| **Class** | The blueprint | `class Car:` |
| **Object (Instance)** | The real thing built from the blueprint | `my_car = Car("Toyota", "Blue")` |
| **Attribute** | Data/variable that belongs to an object | `my_car.color` (Defined in `__init__`) |
| **Method** | Function/behavior that belongs to an object | `my_car.start()` |

### The Power of Encapsulation üß∞
This is the core principle we learned today. It means bundling the data (attributes) and the methods that operate on that data into a single, self-contained unit (the object).

*   The `BankAccount` object *manages its own balance*. You don't have separate functions floating around; you just tell the object what to do (`my_account.deposit(100)`), and it handles its own internal state.
*   This makes code **safer, more organized, and easier to reason about**.

## HANDS-ON LAB: The Car Class üöó

**Goal:** Define a `Car` class that models a real-world car.

### üîß Part 1: The Blueprint (`__init__`)
1.  Define a class named `Car`.
2.  Create the `__init__` method. It should accept `brand` and `color`.
3.  Inside `__init__`, create `self.brand`, `self.color`.
4.  Add an attribute `self.is_running` and initialize it to `False`.
"""

# Part 1: The Blueprint
class Car:
    def __init__(self, brand, color):
        self.brand = brand
        self.color = color
        self.is_running = False # Engine is off by default

    # We will add methods in the next part!

"""### ‚öôÔ∏è Part 2: Adding Behaviors (Methods)
1.  Define a method `start()`.
    *   If the car is already running, print a message.
    *   If it's off, set `self.is_running` to `True` and print a message.
2.  Define a method `stop()`.
    *   If the car is running, turn it off and print a message.
    *   If it's already off, print a message.
*(Use f-strings to include the car's brand in the messages!)*
"""

# Part 2: Adding Behaviors
class Car:
    def __init__(self, brand, color):
        self.brand = brand
        self.color = color
        self.is_running = False

    def start(self):
        if self.is_running:
            print(f"The {self.brand} is already running.")
        else:
            self.is_running = True
            print(f"The {self.brand} starts. Vroom vroom!")

    def stop(self):
        if self.is_running:
            self.is_running = False
            print(f"The {self.brand} engine is turned off.")
        else:
            print(f"The {self.brand} is already off.")

"""### üß™ Part 3: Testing Your Class
1.  Create two different `Car` objects.
2.  Print their attributes.
3.  Call `start()` and `stop()` on them multiple times to test the logic.
"""

# Part 3: Testing
my_car = Car("Toyota", "blue")
your_car = Car("Ford", "red")

print(f"My car is a {my_car.color} {my_car.brand}.")
print(f"Your car is a {your_car.color} {your_car.brand}.")

print("\n--- Testing My Car ---")
my_car.start()
my_car.start() # Try to start it again
my_car.stop()
my_car.stop() # Try to stop it again

print("\n--- Testing Your Car ---")
your_car.start()
your_car.stop()

"""### üöÄ Challenge / Bonus Features
1.  **Add a `__str__` method** to give a nice string representation.
2.  **Add more attributes** like `model` and `year`.
3.  **Create a state-aware method** `drive(self, distance)` that only works if the car is running.
"""

# Challenge: Enhanced Car Class
class Car:
    def __init__(self, brand, model, year, color):
        self.brand = brand
        self.model = model
        self.year = year
        self.color = color
        self.is_running = False
        self.mileage = 0 # Let's track miles driven

    def __str__(self):
        return f"A {self.color} {self.year} {self.brand} {self.model}"

    def start(self):
        if self.is_running:
            print(f"The {self.brand} is already running.")
        else:
            self.is_running = True
            print(f"The {self.brand} starts. Vroom vroom!")

    def stop(self):
        if self.is_running:
            self.is_running = False
            print(f"The {self.brand} engine is turned off.")
        else:
            print(f"The {self.brand} is already off.")

    def drive(self, distance):
        if not self.is_running:
            print("Please start the car first!")
        else:
            self.mileage += distance
            print(f"Driving {distance} miles. Total mileage: {self.mileage}")

# Test the enhanced class
dream_car = Car("Porsche", "911", 2025, "silver")
print(dream_car) # Uses our new __str__ method

dream_car.drive(10) # Should fail
dream_car.start()
dream_car.drive(50)
dream_car.drive(120)
dream_car.stop()