# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#2_L#6_(Date:22-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jwgn0rZtV86pNhbvKmM0tq0McNzJqX8b

# 🧭 Module 1: Core Python & Data - Week 1 Lecture 6
**Date:** 22/08/2025  
**Instructor:** Orangzaib Rajpoot  

## 📋 Directing the Flow: Conditional Logic & Error Handling

We've learned to store and organize data. Today, we give our programs a **brain** 🧠 and a **safety net** 🛡️. We'll learn to make decisions with `if/elif/else` and handle unexpected errors gracefully with `try...except`, creating robust, dynamic programs that don't just crash!

## 📋 Today's Agenda

1.  **🛣️ The Crossroads - `if` and `else` Statements**
    *   Control Flow & The `if` Statement
    *   Python's "Truthiness"
    *   The `else` Statement
    *   Interactive Exercises

2.  **🧭 Handling Multiple Paths & Complex Logic**
    *   The `elif` Statement
    *   Complex Conditions with `and`, `or`, `not`
    *   Interactive Exercises

3.  **🐍 Pythonic Conditionals & Error Handling**
    *   The Ternary Operator
    *   The Problem: Programs That Crash
    *   The Solution: `try...except`
    *   **🧪 Hands-On Lab:** The Number Guessing Game

## 1. 🛣️ The Crossroads - `if` and `else` Statements

### The Concept of Control Flow
Think of a program as a recipe. So far, our recipes have been a straight list of steps. But real instructions involve **decisions**: *"If the oven is hot, put the cake in."*

**Control flow statements** like `if` allow us to direct the path of execution in our code based on certain conditions, making our programs dynamic and intelligent.

### The `if` Statement: The Basic Decision
The `if` statement evaluates a condition. If the condition is `True`, the indented code block runs. If `False`, it is skipped.
"""

# Syntax: if condition:
#             indented_code_block

temperature = 35

if temperature > 30:
    print("It's a hot day! 🔥")
    print("Remember to stay hydrated. 💧")

print("This line always runs, regardless of the condition.")

"""### Python's "Truthiness" ✅❌
In Python, you don't always need an explicit `== True` or `== False`. Many values are considered **"truthy"** or **"falsy"** in a boolean context. This leads to cleaner, more readable code.

**Falsy Values** (behave like `False`):
*   The number `0` or `0.0`
*   An empty string `""`
*   An empty list `[]`, tuple `()`, dictionary `{}`, or set `set()`
*   The special value `None`

**Everything else is Truthy!** (behaves like `True`)
"""

# Checking if a list is empty

user_list = []
# Un-Pythonic way
if len(user_list) == 0:
    print("No users found. (Un-Pythonic)")

# Pythonic way using Truthiness
if not user_list: # Reads like English: "if not user_list"
    print("No users found. (Pythonic)")

# Checking if user input is not empty
name = input("Enter your name: ")
if name: # "if name has a value" (is truthy)
    print(f"Welcome, {name}! 👋")
else:
    print("You didn't enter a name. 😢")

"""### The `else` Statement: The Alternative Path
The `else` statement provides a block of code to execute **if the `if` condition is `False`**.
"""

age = 17

if age >= 18:
    print("You are eligible to vote. 🗳️")
else:
    print("You are not yet eligible to vote.")
    years_left = 18 - age
    print(f"You can vote in {years_left} year(s). ⏳")

"""### 🧠 In-Class Exercise: Login Check

1.  Create a variable `password = "python123"`.
2.  Ask the user to enter a password using `input()`.
3.  Write an `if/else` statement that checks if the user's input matches the stored password.
4.  Print `"Access Granted"` or `"Access Denied"`.
"""

# Exercise: Login Check
password = "python123"

user_input = input("Please enter the password: ")

if user_input == password:
    print("Access Granted! 🎉")
else:
    print("Access Denied! ❌")

"""## 2. 🧭 Handling Multiple Paths & Complex Logic

### The `elif` Statement: The "Else If"
What if you have more than two possible outcomes? You could nest `if/else` statements, but that gets messy. The `elif` (**else if**) statement is the clean, Pythonic solution. Python checks each condition in order and executes the **first** one that is `True`.
"""

score = 85

# Messy Nested Version (Don't do this!)
if score >= 90:
    print("Grade: A")
else:
    if score >= 80:
        print("Grade: B")
    else:
        if score >= 70:
            print("Grade: C")
        # ... gets very messy!

print("-" * 20)

# Clean, Readable 'elif' Version ✅
if score >= 90:
    print("Grade: A")
elif score >= 80: # Else, if this is true...
    print("Grade: B")
elif score >= 70:
    print("Grade: C")
elif score >= 60:
    print("Grade: D")
else: # If none of the above are true...
    print("Grade: F")

"""### Building Complex Conditions with `and`, `or`, `not`
You can combine simple checks to create powerful, specific rules using logical operators.
"""

age = 25
has_license = True

# 'and' requires ALL conditions to be True
if age >= 25 and has_license:
    print("You are eligible to rent a car. 🚗")

day = "Sunday"
is_holiday = False

# 'or' requires AT LEAST ONE condition to be True
if day == "Saturday" or day == "Sunday" or is_holiday:
    print("Enjoy your day off! 🏖️")

# 'not' flips the boolean value
is_raining = False
if not is_raining:
    print("It's not raining. Good day for a walk! 🚶")

"""### 🧠 In-Class Exercise: Theme Park Ride Access

A ride has rules:
- Must be at least **140cm** tall.
- Between **120cm and 140cm**, must be accompanied by an adult.
- Under **120cm**, cannot ride.

Write an `if/elif/else` structure that takes a `height` and a boolean `is_with_adult` and prints the correct message.
"""

# Exercise: Theme Park Ride Access
height = 130  # Try changing this value: 110, 130, 150
is_with_adult = True # Try changing this to False

print(f"Height: {height}cm, With Adult: {is_with_adult}")

if height >= 140:
    print("Access Granted! 🎢")
elif height >= 120:
    if is_with_adult:
        print("Access Granted with adult! 👨‍👦")
    else:
        print("Access Denied. Must be accompanied by an adult. 🚫")
else: # height < 120
    print("Access Denied. Too short. 📏")

"""## 3. 🐍 Pythonic Conditionals & Error Handling

### The Ternary Operator: A Concise if/else
For simple assignments based on a condition, Python offers a clean one-line syntax.

**Syntax:** `value_if_true if condition else value_if_false`

**Use this for clarity on simple assignments, not for complex logic.**
"""

age = 22

# Standard if/else
if age >= 18:
    status = "Adult"
else:
    status = "Minor"

# Ternary operator version (does the same thing in one line)
status = "Adult" if age >= 18 else "Minor"

print(f"The person is a {status}. 👤")

"""### The Problem: When Programs Crash 💥
So far, we've assumed users will always give us the input we expect. What happens when they don't? The program crashes with a **traceback** error message and stops completely.
"""

# The Problem: Crashing on bad input
user_input = input("Please enter your age: ")
# User might type "twenty" instead of 20

# This line will CRASH with a ValueError if input isn't a number!
age = int(user_input)

print("This line will never be reached if the previous one crashes. 😵")

"""### The Solution: Handling Errors with `try...except` 🛡️
The `try...except` block is Python's mechanism for **error handling** (also called **exception handling**). It's another form of control flow.

**Analogy:** You "try" to run some risky code. If an error occurs, instead of crashing, the program jumps to the "except" block, which acts as a safety net.
"""

# The Solution: Graceful error handling
user_input = input("Please enter your age: ")

try:
    # --- Risky code goes here ---
    age = int(user_input) # This might cause a ValueError
    print(f"In five years, you will be {age + 5} years old. 🎂")
except ValueError:
    # --- Fallback code goes here ---
    # This only runs if a ValueError occurred in the try block.
    print("Invalid input! ❌ Please enter a number using digits (e.g., 20), not words.")

print("The program continues gracefully after handling the error. ✅")

"""### 🧠 In-Class Exercise: Safe Division Calculator

1.  Ask the user for a numerator and a denominator.
2.  Convert them to floats.
3.  The division will crash if the denominator is `0` (`ZeroDivisionError`).
4.  Wrap your division in a `try...except` block to catch this error and print a friendly message.
"""

# Exercise: Safe Division Calculator
print("Safe Division Calculator ➗")

numerator = float(input("Enter the numerator: "))
denominator = float(input("Enter the denominator: "))

try:
    result = numerator / denominator
    print(f"The result is: {result}")
except ZeroDivisionError:
    print("Error! 🚫 Cannot divide by zero.")

"""## 🧪 Hands-On Lab: The Number Guessing Game

Let's build a classic game that combines **variables, operators, user input, type casting, conditional logic, loops, and error handling!**

**The Goal:** The program generates a secret number. The user guesses until they get it right, receiving "too high" or "too low" hints.
We'll build it step-by-step.

### 🔧 Part 1: Setup
Import the `random` library and generate a secret number between 1 and 100.
"""

# Part 1: Setup
import random

print("Welcome to the Number Guessing Game! 🎯")
print("I'm thinking of a number between 1 and 100.")
secret_number = random.randint(1, 100)
# print(secret_number) # Uncomment to cheat!

"""### 🔁 Part 2 & 3: The Game Loop & Error Handling
Create an infinite loop and safely get the user's guess using `try...except`.
"""

# Parts 2 & 3: The Game Loop & Error Handling
guess_count = 0

while True:
    # PART 2: Get user input
    user_input = input("\nMake your guess (1-100): ")

    # PART 3: Error handling with try...except
    try:
        user_guess = int(user_input)
        guess_count += 1  # Only count valid guesses
    except ValueError:
        print("❌ That's not a valid number! Please enter a whole number (e.g., 50).")
        continue  # Go back to start of loop

    # ... Logic for checking the guess goes here next ...

"""### ✅ Part 4: The Logic
Compare the guess to the secret number and provide feedback. Use `break` to exit the loop when the user wins.
"""

# Part 4: The Logic (This goes INSIDE the loop, after the try-except block)

    # Check if the guess is correct, too high, or too low
    if user_guess < secret_number:
        print("Too low! 📉 Guess again.")
    elif user_guess > secret_number:
        print("Too high! 📈 Guess again.")
    else:
        print(f"🎉 You got it! The number was {secret_number}.")
        print(f"🕵️ It took you {guess_count} guesses.")
        break  # Exit the game loop

"""### 🚀 Challenge / Bonus Features:
1.  **Turn Counter:** Already implemented! The `guess_count` variable tracks tries.
2.  **Limit Guesses:** Give the user only 7 tries. Let's add this.
"""

# Full Game with Guess Limit
import random

secret_number = random.randint(1, 100)
max_guesses = 7
guess_count = 0

print(f"Welcome! You have {max_guesses} tries to guess the number.")

while guess_count < max_guesses:
    user_input = input("\nMake your guess: ")

    try:
        user_guess = int(user_input)
    except ValueError:
        print("❌ Please enter a valid number.")
        continue # Don't count invalid input as a guess

    guess_count += 1
    guesses_left = max_guesses - guess_count

    if user_guess < secret_number:
        print(f"Too low! 📉 You have {guesses_left} guesses left.")
    elif user_guess > secret_number:
        print(f"Too high! 📈 You have {guesses_left} guesses left.")
    else:
        print(f"🎉 You won! You guessed it in {guess_count} tries!")
        break # Exit the loop on win

# This 'else' clause for the while loop runs if the loop ended normally (no break)
# Meaning, they ran out of guesses without winning.
else:
    print(f"\n💔 Game Over! You ran out of guesses. The number was {secret_number}.")