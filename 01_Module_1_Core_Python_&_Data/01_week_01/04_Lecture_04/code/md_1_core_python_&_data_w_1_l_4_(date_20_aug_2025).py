# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#1_L#4_(Date:20-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ep72kIlfvAgKqW5-Ygc5HuGycj5zDhwS

# ðŸ—ƒï¸ Module 1: Core Python & Data - Week 1 Lecture 4
**Date:** 20/08/2025  
**Documented By:** Muhammad Soban Shaukat

## ðŸ“‹ Python's Collections: Lists and Tuples

So far, we've stored single pieces of data. But the real world is full of **collections**â€”playlists, to-do lists, coordinates. Today, we master Python's foundational tools for handling ordered groups of data: the mighty **List** and the steadfast **Tuple**.

## ðŸ“‹ Today's Agenda

1.  **ðŸŽ The Workhorse - Python Lists**
    *   Creating Lists
    *   **Accessing Data:** Indexing & Slicing
    *   Mutability: Changing Lists
    *   Interactive Exercises

2.  **ðŸ› ï¸ Manipulating Lists & Introducing Tuples**
    *   Essential List Methods: `.append()`, `.pop()`, `.sort()`
    *   **Introduction to Tuples:** The Immutable Sibling
    *   Interactive Exercises

3.  **ðŸ” Tuples in Practice & The Hands-On Lab**
    *   Why Use Tuples?
    *   Tuple Unpacking
    *   **ðŸ§ª Hands-On Lab:** The To-Do List Application

## 1. ðŸŽ The Workhorse - Python Lists

### What is a Sequence?
A **sequence** is a collection where items are stored in a specific, numbered order. Think of it like a series of lockers. **Lists** and **Tuples** are Python's main sequence types.

### Creating Lists
A **list** is an **ordered**, **mutable** (changeable), and **heterogeneous** (can mix types) collection, enclosed in square brackets `[]`.

*   **Ordered:** The position of each item matters. `[1, 2, 3]` is different from `[3, 2, 1]`.
*   **Mutable:** You can change the list after creating it.
*   **Heterogeneous:** A single list can hold different data types (unlike arrays in many other languages).
"""

# A list of integers
primes = [2, 3, 5, 7, 11]
print("Primes:", primes)

# A list of strings
tasks = ["code", "eat", "sleep"]
print("Tasks:", tasks)

# A mixed-type list (Perfectly valid in Python!)
user_profile = ["Alice", 30, True, 98.6]
print("User Profile:", user_profile)

"""### Accessing Data Part 1: Indexing
You access an item in a list by its **index** (its position). Python uses **zero-based indexing**, meaning the first item is at index `0`.
"""

#            0        1        2        3
fruits = ["apple", "banana", "cherry", "date"]

print("fruits[0]:", fruits[0]) # Output: apple
print("fruits[2]:", fruits[2]) # Output: cherry

"""#### Negative Indexing: A Python Superpower
Use negative numbers to count backwards from the end of the list.
*   `-1` is the last item
*   `-2` is the second-to-last item, and so on.
"""

#            0        1        2        3
fruits = ["apple", "banana", "cherry", "date"]
#            -4       -3       -2       -1

print("fruits[-1]:", fruits[-1]) # Output: date (last item)
print("fruits[-3]:", fruits[-3]) # Output: banana (third from last)

"""### ðŸ§  In-Class Exercise: Access Check

Given the list `planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter"]`:
*   Write the code to print `"Earth"`.
*   Write the code to print the last planet using **negative indexing**.
"""

# Exercise: Access Check
planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter"]

# Print "Earth"
print(planets[2])

# Print the last planet using negative indexing
print(planets[-1])

"""### Mutability: Changing List Items
Lists are **mutable**. You can change an item by assigning a new value to its index.
"""

# Mutability in action
numbers = [1, 2, 99, 4]
print("Before change:", numbers)

numbers[2] = 3 # Change the value at index 2 from 99 to 3
print("After change:", numbers)

"""### Accessing Data Part 2: Slicing ðŸ•
**Slicing** lets you extract a sub-list (a "slice") from a list. The syntax is `list[start:stop:step]`.
*   `start`: Index to start at (**inclusive**). Defaults to `0`.
*   `stop`: Index to stop at (**exclusive**). Defaults to `len(list)`.
*   `step`: How many items to skip. Defaults to `1`.
"""

# Index: 0   1   2   3   4   5   6   7
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

print("letters[2:5]:", letters[2:5])   # Items from index 2 to 4 -> ['c', 'd', 'e']
print("letters[4:]:", letters[4:])     # Items from index 4 to end -> ['e', 'f', 'g', 'h']
print("letters[:3]:", letters[:3])     # Items from start to index 2 -> ['a', 'b', 'c']
print("letters[::2]:", letters[::2])   # Every other item -> ['a', 'c', 'e', 'g']
print("letters[::-1]:", letters[::-1]) # A classic trick: reverse the list! -> ['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']

"""### ðŸ§  In-Class Exercise: Slicing Practice

Given `numbers = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]`:
*   Write a slice to get `[30, 40, 50]`.
*   Write a slice to get the last two numbers.
*   Write a slice to get every third number, starting from the beginning.
"""

# Exercise: Slicing Practice
numbers = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]

# Slice for [30, 40, 50]
print(numbers[3:6])

# Slice for the last two numbers
print(numbers[-2:])

# Slice for every third number
print(numbers[::3])

"""## 2. ðŸ› ï¸ Manipulating Lists & Introducing Tuples

### Essential List Methods
Methods are functions that belong to an object (like our list). They are called using the dot `.` syntax: `list_name.method()`.

#### Adding Items
*   `.append(item)`: Adds a single item to the **end** of the list.
*   `.insert(index, item)`: Inserts an item at a specific `index`, shifting other items to the right.
"""

# Adding items to a list
todo_list = ["wash car", "buy groceries"]
print("Original:", todo_list)

todo_list.append("pay bills") # Add to the end
print("After append:", todo_list)

todo_list.insert(1, "clean room") # Insert at index 1
print("After insert:", todo_list)

"""#### Removing Items
*   `.remove(value)`: Removes the **first occurrence** of the specified value.
*   `.pop(index)`: Removes and **returns** the item at the specified `index`. If no index is given, it removes the last item.
*   `del list[index]`: The `del` keyword can also remove an item at a specific index.
"""

# Removing items from a list
items = ['a', 'b', 'c', 'b', 'd']
print("Original:", items)

items.remove('b') # Removes the first 'b'
print("After remove('b'):", items)

popped_item = items.pop() # Removes and returns the last item
print("Popped item:", popped_item)
print("After pop():", items)

del items[0] # Deletes the item at index 0
print("After del items[0]:", items)

"""### ðŸ§  In-Class Exercise: Playlist Manager

Start with `playlist = ["Song A", "Song C"]`.
1.  Add `"Song D"` to the end.
2.  Insert `"Song B"` at the correct position (index 1).
3.  Remove `"Song A"`.
4.  Print the final playlist.
"""

# Exercise: Playlist Manager
playlist = ["Song A", "Song C"]
print("Initial Playlist:", playlist)

# 1. Add "Song D" to the end
playlist.append("Song D")

# 2. Insert "Song B" at index 1
playlist.insert(1, "Song B")

# 3. Remove "Song A"
playlist.remove("Song A")

print("Final Playlist:", playlist)

"""### Sorting and Organizing
*   `.sort()`: Sorts the list **in-place** (modifies the original list) in ascending order.
*   `.sort(reverse=True)`: Sorts in descending order.
*   `.reverse()`: Reverses the order of the list **in-place**.
*   `sorted(list)`: **Returns a new, sorted list** without changing the original. Accepts `reverse=True`.
"""

# Sorting Lists
numbers = [4, 1, 7, 3, 15]
print("Original numbers:", numbers)

numbers.sort() # In-place sort
print("After .sort():", numbers)

numbers.sort(reverse=True) # In-place descending sort
print("After .sort(reverse=True):", numbers)

scores = [88, 95, 72, 100, 88]
print("\nOriginal scores:", scores)

sorted_scores = sorted(scores) # New sorted list, original unchanged
print("New sorted_scores list:", sorted_scores)
print("Original scores is unchanged:", scores)

descending_scores = sorted(scores, reverse=True)
print("New descending_scores list:", descending_scores)

"""### ðŸ§  In-Class Exercise: Leaderboard Ranking

You have a list of player scores: `leaderboard = [1050, 2300, 850, 1700]`.
1.  Create a new list `top_scores` with the scores sorted highest to lowest, **without changing** the original.
2.  Permanently **reverse** the order of the original `leaderboard` list.
3.  Print both lists.
"""

# Exercise: Leaderboard Ranking
leaderboard = [1050, 2300, 850, 1700]
print("Original Leaderboard:", leaderboard)

# 1. Create new sorted list (descending)
top_scores = sorted(leaderboard, reverse=True)
print("New Top Scores (descending):", top_scores)

# 2. Permanently reverse the original list
leaderboard.reverse()
print("Original Leaderboard (reversed):", leaderboard)

"""## Introduction to Tuples: The Immutable Sibling

A **tuple** is an **ordered** and **immutable** (unchangeable) collection, enclosed in parentheses `()`.

*   **Immutable:** This is the key difference. Once created, you **cannot** change a tupleâ€”no adding, removing, or changing items.
*   **Use Case:** Perfect for representing fixed data like coordinates, RGB colors, or database records.
"""

# Creating Tuples
point = (10, 20)          # A tuple of coordinates
red_color = (255, 0, 0)   # A tuple for an RGB color
print("Point:", point)
print("Red Color:", red_color)

# A common pitfall: creating a tuple with one item requires a trailing comma.
single_item_tuple = (42,) # This is a tuple
not_a_tuple = (42)        # This is just the integer 42
print("Type of single_item_tuple:", type(single_item_tuple))
print("Type of not_a_tuple:", type(not_a_tuple))

# You can access tuples with indexing and slicing, just like lists.
print("First coordinate:", point[0])
print("Color slice:", red_color[:2]) # Gets (255, 0)

# But you CANNOT change them!
# point[0] = 15 # This line would cause a TypeError: 'tuple' object does not support item assignment

"""## 3. ðŸ” Tuples in Practice & The Hands-On Lab

### Why Use Tuples?
If they seem like limited lists, why do they exist?
*   **Data Integrity:** Protects constant data from accidental changes (e.g., `DAYS_OF_WEEK = ("Mon", "Tue", "Wed", ...)`).
*   **Performance:** Tuples are slightly faster and use less memory than lists, which matters in large applications.
*   **Dictionary Keys:** Tuples can be used as keys in dictionaries (because they are immutable); lists cannot. (We'll see this soon!).

### Tuple Unpacking: A Pythonic Superpower
This is a beautiful, clean way to assign the items of a tuple to multiple variables in one line.
"""

# Tuple Unpacking
location = (34.0522, -118.2437) # Latitude, Longitude for Los Angeles

# The Pythonic way: unpack into named variables
latitude, longitude = location

print(f"Latitude: {latitude}")
print(f"Longitude: {longitude}")

# This is much cleaner than:
# latitude = location[0]
# longitude = location[1]

"""### ðŸ§  In-Class Exercise: Unpacking Colors

Given `primary_colors = [("red", "#FF0000"), ("green", "#00FF00"), ("blue", "#0000FF")]` (a list of tuples).
Write code to unpack the **first element** into two variables, `color_name` and `hex_code`, and print them.
"""

# Exercise: Unpacking Colors
primary_colors = [("red", "#FF0000"), ("green", "#00FF00"), ("blue", "#0000FF")]

# Unpack the first tuple in the list
first_color_tuple = primary_colors[0] # This gets ("red", "#FF0000")
color_name, hex_code = first_color_tuple # This unpacks the tuple

print(f"Color Name: {color_name}")
print(f"Hex Code: {hex_code}")

# Advanced: You can do it in one line!
color_name, hex_code = primary_colors[0]
print(f"One-liner -> Color: {color_name}, Code: {hex_code}")

"""## ðŸ§ª Hands-On Lab: The To-Do List Application

Let's build a simple, text-based to-do list manager to practice everything we've learned!
We'll build it step-by-step. You can run each cell after writing the code.

### ðŸ”§ Part 1: Setup
Create a list named `tasks` with some initial items.
"""

# Part 1: Setup
tasks = ["Learn Python lists", "Build a to-do app", "Take a break"]
print("Initial tasks list created!")

"""### ðŸ‘€ Part 2: Viewing Tasks
Write code to display the current tasks. If the list is empty, print a message. If it has items, print them with numbers starting from 1.
*Hint: We haven't officially learned loops, so we'll use a simple method for now.*
"""

# Part 2: Viewing Tasks
def view_tasks():
  if not tasks: # This checks if the list is empty
    print("Your to-do list is empty! ðŸŽ‰")
  else:
    print("\nðŸ“‹ Your To-Do List:")
    # We'll use a simple method for now (enumerate is better, coming soon!)
    for i in range(len(tasks)):
      print(f"  {i+1}. {tasks[i]}") # i+1 makes it start at 1 for the user

# Let's test our function
view_tasks()

"""### âž• Part 3: Adding a Task
Prompt the user for a new task and add it to the list using `.append()`.
"""

# Part 3: Adding a Task
def add_task():
  new_task = input("\nWhat task would you like to add? ")
  tasks.append(new_task)
  print(f"Task '{new_task}' has been added to your list. âœ…")

# Let's test adding a task
add_task()
# Now view the list to see the new task
view_tasks()

"""### âž– Part 4: Removing a Task
Show the list, ask the user for a task number to remove, convert it to an integer, adjust for zero-based indexing, and use `.pop()`.
"""

# Part 4: Removing a Task
def remove_task():
  view_tasks() # Show the list first
  if tasks: # Only try to remove if the list isn't empty
    try:
      task_num = int(input("\nEnter the number of the task to remove: "))
      # Adjust for zero-based index and check if it's valid
      index_to_remove = task_num - 1
      if 0 <= index_to_remove < len(tasks):
        removed_task = tasks.pop(index_to_remove)
        print(f"Task '{removed_task}' has been removed. âŒ")
      else:
        print("Invalid task number. Please try again.")
    except ValueError: # This catches if the user doesn't enter a number
      print("Please enter a valid number.")

# Let's test removing a task
remove_task()
view_tasks() # Check the updated list

"""### ðŸš€ Challenge / Bonus Features
1.  Add a check for valid input in `remove_task()` (already done above with `try-except` and index check!).
2.  Add an option to clear the entire list.
3.  Wrap the application in a `while` loop to keep it running.
"""

# Challenge: Clear entire list and Main Program Loop
def clear_list():
  global tasks # This tells the function to use the global 'tasks' variable
  confirmation = input("Are you sure you want to clear the entire list? (y/n): ").lower()
  if confirmation == 'y':
    tasks.clear()
    print("Your to-do list has been cleared. ðŸ§¹")

# The main application loop
def run_todo_app():
  while True:
    print("\n" + "="*30)
    print("ðŸ—’ï¸  TO-DO LIST MANAGER")
    print("="*30)
    print("1. View Tasks")
    print("2. Add Task")
    print("3. Remove Task")
    print("4. Clear All Tasks")
    print("5. Quit")

    choice = input("\nWhat would you like to do? (1-5): ")

    if choice == '1':
      view_tasks()
    elif choice == '2':
      add_task()
    elif choice == '3':
      remove_task()
    elif choice == '4':
      clear_list()
    elif choice == '5':
      print("Goodbye! ðŸ‘‹")
      break
    else:
      print("Invalid choice. Please enter a number between 1 and 5.")

# Uncomment the line below to RUN THE FULL APPLICATION!
run_todo_app()