# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#1_L#5_(Date:21-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-J_FxAQMHhq5l0ouLBJGVhMX7DNUbia8

# üóÇÔ∏è Module 1: Core Python & Data - Week 1 Lecture 5
**Date:** 21/08/2025  
**Instructor:** Orangzaib Rajpoot  

## üìã Python's Collections (Part 2): Dictionaries & Sets

Last time, we mastered **Lists** and **Tuples**‚Äîcollections ordered by number. Today, we unlock a new superpower: organizing data by custom labels with **Dictionaries** and ensuring uniqueness with **Sets**. These are the building blocks for real-world data!

## üìã Today's Agenda

1.  **üóÑÔ∏è The Ultimate Filing Cabinet - Dictionaries**
    *   Key-Value Pairs
    *   CRUD Operations: Create, Read, Update, Delete
    *   Safe Access with `.get()`
    *   Interactive Exercises

2.  **üîÑ Advanced Dictionaries & Intro to Sets**
    *   Iterating: `.keys()`, `.values()`, `.items()`
    *   **Nesting:** Dictionaries within Dictionaries
    *   **Introduction to Sets:** Uniqueness Enforcers
    *   Interactive Exercises

3.  **‚ûó Set Operations & The Hands-On Lab**
    *   Union, Intersection, Difference
    *   Set vs. List: When to Use Which
    *   **üß™ Hands-On Lab:** The Contact Book Application

## 1. üóÑÔ∏è The Ultimate Filing Cabinet - Dictionaries

### Beyond the Index: Key-Value Pairs
Imagine a filing cabinet. You find files by their **label** ("Project Alpha"), not their position ("5th file"). A **Python dictionary** works the same way. It's an *unordered* collection of **key-value pairs**.

*   **Key:** The unique, immutable label (e.g., a string, number, or tuple).
*   **Value:** The data associated with the key (can be *any* data type).
*   **Syntax:** Dictionaries are enclosed in curly braces `{}`.
"""

# A simple dictionary representing a user
user = {
    "username": "ada_lovelace",
    "email": "ada@example.com",
    "id": 1815,
    "is_active": True
}

print("User dictionary:", user)
print("Type:", type(user))

"""### CRUD Operations: Create, Read, Update, Delete

#### Create / Update
Use square bracket assignment. If the key exists, its value is updated. If it doesn't, a new key-value pair is created.
"""

# Create a new key-value pair
user["last_login"] = "2025-08-20"
print("After adding 'last_login':", user)

# Update an existing value
user["email"] = "ada.lovelace@newdomain.com"
print("After updating 'email':", user)

"""#### Read / Access
Access a value by its key using square brackets.
"""

# Read a value
print("Username:", user["username"])

"""##### üö® Danger Zone: KeyError
Trying to access a key that doesn't exist will crash your program with a `KeyError`.
"""

# This will cause a KeyError and stop the program
# print(user["location"]) # UNCOMMENT ONLY TO SEE THE ERROR

"""#### Safe Access with .get()
The `.get()` method is the safe way to access data. It returns `None` if the key is missing, or a default value you specify.
"""

# Safe access - returns None if key doesn't exist
location = user.get("location")
print("Location (using .get()):", location)

# Safe access with a custom default value
location = user.get("location", "Location not specified")
print("Location (with default):", location)

"""#### Delete
Use the `del` keyword or the `.pop()` method (which also returns the value).
"""

# Using 'del'
del user["is_active"]
print("After deleting 'is_active':", user)

# Using '.pop()' - returns the value
user_id = user.pop("id")
print(f"Removed user with ID: {user_id}")
print("Dictionary after .pop():", user)

"""### üß† In-Class Exercise: Car Inventory

1.  Create a dictionary `car` with keys `"make"`, `"model"`, and `"year"`.
2.  Add a new key `"color"`.
3.  Update the `"year"`.
4.  Safely get the value for `"engine_type"`, providing a default value of `"unknown"`.
5.  Print the final dictionary.
"""

# Exercise: Car Inventory
car = {
    "make": "Tesla",
    "model": "Model S",
    "year": 2020
}

# 1. Add a new key "color"
car["color"] = "Red"

# 2. Update the "year"
car["year"] = 2025

# 3. Safely get "engine_type"
engine = car.get("engine_type", "unknown")

# 4. Print the final dictionary and the engine type
print("Final car dictionary:", car)
print("Engine type:", engine)

"""## 2. üîÑ Advanced Dictionaries & Intro to Sets

### Iterating Over Dictionaries
How do you loop through all the data? Python gives you three clear ways.
"""

student = {"name": "Alan Turing", "major": "Computer Science", "id": 1912}

print("--- Method 1: Looping over KEYS (default) ---")
for key in student: # This is the same as `for key in student.keys():`
    print(f"{key}: {student[key]}")

print("\n--- Method 2: Looping over VALUES ---")
for value in student.values():
    print(value)

print("\n--- Method 3: Looping over ITEMS (BEST WAY!) ---")
for key, value in student.items(): # Tuple unpacking in action!
    print(f"The student's {key} is {value}.")

"""### Nesting: Building Complex Structures
The real power of dictionaries shines when you nest other collections inside them. This is how complex data (like from a web API) is structured.
"""

# A dictionary where a value is a LIST
course = {
    "name": "Intro to AI",
    "course_code": "CS101",
    "students": ["Alice", "Bob", "Charlie"]
}
print("Course with student list:", course)

# A dictionary where a value is another DICTIONARY
users = {
    "user_123": {"name": "Alice", "email": "alice@example.com"},
    "user_456": {"name": "Bob", "email": "bob@example.com"}
}
print("\nNested user dictionary:", users)

# Accessing Nested Data
print("\n--- Accessing Nested Data ---")
first_student = course["students"][0] # Access list, then index
print("First student:", first_student)

bobs_email = users["user_456"]["email"] # Access outer dict, then inner dict
print("Bob's email:", bobs_email)

"""### üß† In-Class Exercise: Course Roster

Given the `course` dictionary:
1.  Add a new student, `"Diana"`, to the `students` list.
2.  Add a new key `"topics"` with a list of topics.
3.  Write a loop that prints each topic.
"""

# Exercise: Course Roster
course = {
    "name": "Intro to AI",
    "course_code": "CS101",
    "students": ["Alice", "Bob", "Charlie"]
}

# 1. Add "Diana" to the students list
course["students"].append("Diana")
print("Students after adding Diana:", course["students"])

# 2. Add a new key "topics"
course["topics"] = ["Machine Learning", "Search Algorithms", "Logic"]

# 3. Loop through and print each topic
print("\nCourse Topics:")
for topic in course["topics"]:
    print(f"- {topic}")

"""## Introduction to Sets: The Uniqueness Enforcer ü¶Ñ

A **set** is an *unordered* collection of *unique* items. Enclosed in curly braces `{}`, but unlike dictionaries, they only have values, not key-value pairs.

*   **Unordered:** Items have no index. You cannot access them by position.
*   **Unique:** Sets automatically discard any duplicate values.
*   **Use Case:** Perfect for finding unique items, comparing groups, and membership tests.
"""

# Creating a set from a list automatically removes duplicates
numbers_list = [1, 2, 2, 3, 4, 4, 4, 5]
unique_numbers = set(numbers_list)
print("List:", numbers_list)
print("Set from list:", unique_numbers)

# Creating a set directly (duplicates are ignored)
tags = {"python", "ai", "data", "python"}
print("Tags set:", tags) # Order is not guaranteed

# An empty set is created with set(), not {}
empty_set = set()
print("Type of empty_set:", type(empty_set))
empty_dict = {}
print("Type of empty_dict:", type(empty_dict))

"""## 3. ‚ûó Set Operations & The Hands-On Lab

### Practical Set Operations
Sets are fantastic for comparing groups of data.
"""

dev_team_A = {"Alice", "Bob", "Charlie", "David"}
dev_team_B = {"Charlie", "David", "Eve", "Frank"}

print("Team A:", dev_team_A)
print("Team B:", dev_team_B)

# Union (|): All unique members from both sets
all_devs = dev_team_A | dev_team_B
print("\nAll Developers (Union):", all_devs)

# Intersection (&): Members in BOTH sets
overlap = dev_team_A & dev_team_B
print("Overlapping Developers (Intersection):", overlap)

# Difference (-): Members in first set but NOT in the second
only_in_A = dev_team_A - dev_team_B
print("Only in Team A (Difference):", only_in_A)

"""### Use Cases: Set vs. List

| Use a **List** when... | Use a **Set** when... |
| :--- | :--- |
| Order matters üé≠ | You need unique items ü¶Ñ |
| You have duplicates üìù | Membership testing is key üîç |
| You need to access items by index üìç | You need to compare groups (union, intersection) ü§ù |
| *Example: A to-do list* | *Example: Tags on a blog post* |

### üß† In-Class Exercise: Skill Comparison

Given two sets of job skills:
1.  Find the skills required for **both** jobs (Intersection).
2.  Find the skills required for job A but **not** job B (Difference).
3.  Create a set of all unique skills required for either job (Union).
"""

# Exercise: Skill Comparison
job_A_skills = {"Python", "SQL", "Tableau", "Git"}
job_B_skills = {"Python", "Java", "AWS", "Git"}

print("Job A Skills:", job_A_skills)
print("Job B Skills:", job_B_skills)

# 1. Skills required for both jobs
common_skills = job_A_skills & job_B_skills
print("\nSkills for both jobs (Intersection):", common_skills)

# 2. Skills only in Job A
only_A_skills = job_A_skills - job_B_skills
print("Skills only in Job A (Difference):", only_A_skills)

# 3. All unique skills across both jobs
all_skills = job_A_skills | job_B_skills
print("All unique skills (Union):", all_skills)

"""## üß™ Hands-On Lab: The Contact Book Application

Let's build a simple contact manager using a dictionary! We'll build it step-by-step.

### üîß Part 1: Setup
Create a dictionary called `contact_book`. The keys will be names (strings), and the values will be phone numbers (strings). Pre-populate it.
"""

# Part 1: Setup
contact_book = {
    "Alice": "555-1234",
    "Bob": "555-5678",
    "Charlie": "555-9012"
}
print("Initial contact book created!")

"""### üëÄ Part 2: Viewing All Contacts
Write a function to iterate through `contact_book` using `.items()` and print each contact.
"""

# Part 2: Viewing All Contacts
def view_contacts():
    if not contact_book: # Check if dictionary is empty
        print("Your contact book is empty.")
    else:
        print("\nüìû Your Contacts:")
        for name, number in contact_book.items():
            print(f"   {name}: {number}")

# Test the function
view_contacts()

"""### ‚ûï Part 3: Adding or Updating a Contact
Prompt the user for a name and number, then add/update it in the dictionary.
"""

# Part 3: Adding or Updating a Contact
def add_contact():
    name = input("\nEnter the contact's name: ").strip().title()
    phone = input("Enter the contact's phone number: ").strip()
    contact_book[name] = phone # This adds or updates the key
    print(f"‚úÖ Contact '{name}' saved with number '{phone}'.")

# Test the function
add_contact()
view_contacts() # View to see the new contact

"""### üîç Part 4: Searching for a Contact
Prompt the user for a name and use `.get()` to safely retrieve and display the number.
"""

# Part 4: Searching for a Contact
def search_contact():
    name = input("\nEnter the name to search for: ").strip().title()
    phone = contact_book.get(name) # Safe lookup

    if phone:
        print(f"‚úÖ Found {name}: {phone}")
    else:
        print(f"‚ùå Sorry, '{name}' was not found in your contacts.")

# Test the function
search_contact()

"""### üóëÔ∏è Part 5: Deleting a Contact
Prompt the user for a name, check if it exists, and then delete it using `.pop()`.
"""

# Part 5: Deleting a Contact
def delete_contact():
    name = input("\nEnter the name to delete: ").strip().title()
    if name in contact_book: # Check if the key exists first
        removed_number = contact_book.pop(name)
        print(f"‚úÖ Removed '{name}' ({removed_number}) from contacts.")
    else:
        print(f"‚ùå Cannot delete. '{name}' not found in contacts.")

# Test the function
delete_contact()
view_contacts() # View to see the contact removed

"""### üöÄ Challenge / Bonus Features

1.  **Complex Data:** Modify `contact_book` so each value is another dictionary storing `phone` and `email`.
2.  **Unique Groups:** Add a list of `tags` (e.g., "work", "family") to each contact. Write a function to find all unique tags used.
"""

# Challenge: Complex Data Structure
# Let's upgrade our contact book!
contact_book_advanced = {
    "Alice": {"phone": "555-1234", "email": "alice@example.com", "tags": ["work", "friend"]},
    "Bob": {"phone": "555-5678", "email": "bob@example.com", "tags": ["family"]},
    "Charlie": {"phone": "555-9012", "email": "charlie@example.com", "tags": ["work"]}
}

print("\n--- Advanced Contact Book ---")
for name, info in contact_book_advanced.items():
    print(f"{name}: {info}")

# Challenge: Find all unique tags
print("\n--- Finding All Unique Tags ---")
all_tags_set = set() # Start with an empty set
for info in contact_book_advanced.values():
    all_tags_set.update(info["tags"]) # Add all tags from this contact to the set

print("All unique tags:", all_tags_set)

"""### üéØ Main Application Loop
Let's wrap everything in a menu system to create a full application.
"""

# Main Application Loop
def run_contact_app():
    while True:
        print("\n" + "="*30)
        print("üìí CONTACT BOOK MANAGER")
        print("="*30)
        print("1. View All Contacts")
        print("2. Add/Update Contact")
        print("3. Search Contact")
        print("4. Delete Contact")
        print("5. Exit")

        choice = input("\nPlease choose an option (1-5): ")

        if choice == '1':
            view_contacts()
        elif choice == '2':
            add_contact()
        elif choice == '3':
            search_contact()
        elif choice == '4':
            delete_contact()
        elif choice == '5':
            print("Goodbye! üëã")
            break
        else:
            print("Invalid choice. Please try again.")

# Uncomment the line below to RUN THE FULL APPLICATION!
run_contact_app()