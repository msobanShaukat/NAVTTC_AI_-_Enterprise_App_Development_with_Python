# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#2_L#8_(Date:26-Aug-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12ves5di1EYXgkzzVY230jx2EDmFbnmUI

# 🧱 Module 1: Core Python & Data - Week 2 Lecture 8
**Date:** 26/08/2025  
**Documented By:** Muhammad Soban Shuakat

## 📋 The Art of Reusability: Building with Functions

Welcome back! Today, we transition from writing simple scripts 🐍 to creating **structured, professional code** 💼. **Functions** are the fundamental building blocks that allow us to name a piece of logic, package it up, and reuse it. Mastering them is the key to writing clean, efficient, and scalable programs.

## 📋 Today's Agenda

1.  **🤔 The "What" and "Why" of Functions**
    *   The DRY Principle
    *   Defining Functions: `def`, `pass`
    *   Naming Conventions
    *   Parameters vs. Arguments
    *   The `return` Statement
    *   Interactive Exercises

2.  **🎛️ Flexible Arguments & Advanced Returns**
    *   Positional vs. Keyword Arguments
    *   Default Values
    *   `*args` and `**kwargs`
    *   `return` vs. `yield` (Generators)
    *   Interactive Exercises

3.  **🏗️ Structuring Python Scripts & The Lab**
    *   Variable Scope: Local vs. Global
    *   Docstrings: Documenting Your Code
    *   The `main()` Function Pattern
    *   `if __name__ == "__main__":`
    *   Command-Line Arguments with `sys.argv`
    *   **🧪 Hands-On Lab:** Refactoring Previous Projects

## 1. 🤔 The "What" and "Why" of Functions

### The DRY Principle: Don't Repeat Yourself
This is a core philosophy in programming. If you find yourself writing the same code multiple times, it's a sign you need a **function**.

**Why is repeating code bad?** 🤕
*   **Error-Prone:** Fixing a bug means finding and fixing it in every copied spot.
*   **Hard to Read:** Long scripts are confusing. Named chunks are logical.
*   **Hard to Maintain:** Changing logic requires updates in many places.

**Functions solve this** by providing a **single source of truth** for a piece of logic.

### Defining a Function: The `def` Statement
A function is a **named block of code** that performs a specific task. You define it using the `def` keyword followed by the function name and parentheses `()`.

**Syntax:** `def function_name():`
"""

# Defining a simple function
def print_welcome_message():
    print("---")
    print("Welcome to the App! 🎉")
    print("---")

# To use the function, you must "call" it by its name:
print_welcome_message()
print_welcome_message() # We can reuse it easily!

"""### The `pass` Statement: A Placeholder
Python requires an indented block after `def`. The `pass` statement is a **null operation**—it does nothing. It's a perfect placeholder for future code, preventing `IndentationError`.
"""

# Using pass as a placeholder
def fetch_user_data_from_db():
    # TODO: Add database connection logic later
    pass # This is a valid, empty function

def calculate_advanced_metrics():
    pass # Will implement after testing basics

print("Planning my program structure...")
fetch_user_data_from_db() # This runs without error
print("Structure is valid. ✅")

"""### Python Function Naming Conventions
Use these rules for clean, readable code:
*   **snake_case:** Use lowercase letters with words separated by underscores.
*   **Verb-Noun:** Names should be descriptive (e.g., `calculate_total`, `get_user_input`).
"""

# Good, Pythonic function names
def calculate_average(numbers):
    pass

def send_email(recipient, subject, body):
    pass

def validate_user_input(input_string):
    pass

# Bad, non-Pythonic names
def CalcAvg(): # PascalCase, not snake_case
    pass
def do_stuff(): # Not descriptive
    pass

"""### Parameters vs. Arguments
*   **Parameter:** The variable name inside the function's definition. It's a **placeholder**.
*   **Argument:** The actual value you **pass** to the function when you call it.
"""

# 'name' is a parameter
def greet_user(name):
    print(f"Hello, {name}! 👋")

# "Alice" is an argument
greet_user("Alice")
greet_user("Bob") # We can reuse the function with different arguments

"""### The `return` Statement: Getting a Value Back
Functions aren't just for printing; they often **calculate** a result and need to **send it back**. The `return` statement does this. It immediately exits the function and returns the value.
"""

# A function that returns a value
def add_numbers(a, b): # 'a' and 'b' are parameters
    result = a + b
    return result # Sends the result back to the caller

# Calling the function and capturing its return value
sum_of_numbers = add_numbers(5, 10) # 5 and 10 are arguments
print(f"The sum is: {sum_of_numbers}")

# You can use the return value directly in expressions
double_the_sum = add_numbers(5, 10) * 2
print(f"Double the sum is: {double_the_sum}")

"""### 🧠 In-Class Exercise: Area Calculator Function

1.  Write a function called `calculate_area`.
2.  It should take two parameters: `width` and `height`.
3.  Inside, calculate the area (width * height).
4.  The function should **return** the area.
5.  Call the function with arguments and print the result.
"""

# Exercise: Area Calculator Function
def calculate_area(width, height):
    area = width * height
    return area

# Test the function
room_area = calculate_area(10, 5) # Pass 10 and 5 as arguments
print(f"The area of the room is: {room_area} square units.")

# You can also call it inside a print statement
print(f"The area is: {calculate_area(7, 3)}")

"""## 2. 🎛️ Flexible Arguments & Advanced Returns

### Positional vs. Keyword Arguments
*   **Positional Arguments:** Matched to parameters based on **order**.
*   **Keyword Arguments:** Matched by explicitly **naming** the parameter. This frees you from order.
"""

def describe_pet(animal_type, pet_name):
    print(f"I have a {animal_type} named {pet_name}. 🐾")

# Positional arguments (order matters!)
describe_pet("hamster", "Harry") # Correct order

# Keyword arguments (order doesn't matter!)
describe_pet(pet_name="Willow", animal_type="dog") # Explicit names

# You can mix them, but positional must come first!
describe_pet("cat", pet_name="Mittens") # This is fine
# describe_pet(pet_name="Buddy", "parrot") # This would cause a SyntaxError

"""### Default Parameter Values
You can provide a **default value** for a parameter. If an argument isn't provided, the default is used.
"""

# animal_type has a default value of "dog"
def describe_pet(pet_name, animal_type="dog"):
    print(f"I have a {animal_type} named {pet_name}. 🐾")

describe_pet("Willow") # Uses the default "dog"
describe_pet("Goldie", animal_type="fish") # Overrides the default
describe_pet("Charlie", "rabbit") # Uses positional for both

"""### Arbitrary Arguments: `*args` and `**kwargs`
What if you don’t know how many arguments a function will receive?
*   `*args`: Gathers extra **positional** arguments into a **tuple**.
*   `**kwargs`: Gathers extra **keyword** arguments into a **dictionary**.
"""

# *args example: sum any number of values
def sum_all(*numbers): # The asterisk (*) is key!
    print(f"Numbers tuple: {numbers}") # Let's see what it captures
    total = 0
    for num in numbers:
        total += num
    return total

result = sum_all(1, 2, 3, 4, 5) # We can pass any number of arguments!
print(f"The sum is: {result}")

# **kwargs example: build a user profile
def build_profile(first, last, **user_info): # Double asterisk (**)
    profile = {'first_name': first, 'last_name': last}
    for key, value in user_info.items(): # user_info is a dictionary
        profile[key] = value
    return profile

user_profile = build_profile('albert', 'einstein',
                             location='princeton',
                             field='physics')
print(f"User Profile: {user_profile}")

"""### 🧠 In-Class Exercise: Pizza Order

Write a function `make_pizza(size, *toppings)`.
*   It should print a summary of the pizza order.
*   Loop through the `toppings` tuple and print each one.
*   Call it with different sizes and numbers of toppings.
"""

# Exercise: Pizza Order
def make_pizza(size, *toppings):
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    if toppings: # Check if there are any toppings
        for topping in toppings:
            print(f"  - {topping}")
    else:
        print("  No toppings! Just a classic cheese pizza. 🧀")

# Test the function
make_pizza(12, "pepperoni", "mushrooms", "green peppers")
make_pizza(8, "extra cheese")
make_pizza(10) # No toppings provided

"""### Advanced Returns: `return` vs. `yield`
*   `return`: Terminates the function and sends back a **single value**.
*   `yield`: Turns a function into a **generator**. It **pauses** the function, yields a value, and remembers its state for the next call. Perfect for huge sequences of data as it's memory efficient.
"""

# Generator function using yield
def get_even_numbers_generator(limit):
    for i in range(limit):
        if i % 2 == 0:
            yield i  # Pauses here and returns i
            # When called again, it resumes from here

# Using the generator
print("Even numbers up to 10:")
for number in get_even_numbers_generator(10):
    print(number, end=" ")
print("\n")

# Contrast with a normal function using return
def get_even_numbers_list(limit):
    result = []
    for i in range(limit):
        if i % 2 == 0:
            result.append(i)
    return result # Returns the entire list at once

print("Using a normal function (returns a list):")
print(get_even_numbers_list(10))

"""### 🧠 In-Class Exercise: Countdown Generator

Write a generator function `countdown(start)` that yields numbers from `start` down to 1.
"""

# Exercise: Countdown Generator
def countdown(start):
    current = start
    while current >= 1:
        yield current
        current -= 1

print("Countdown from 5:")
for num in countdown(5):
    print(f"T-minus {num}...")
print("Blast off! 🚀")

"""## 3. 🏗️ Structuring Python Scripts & The Lab

### Variable Scope: Local vs. Global
*   **Global Scope:** A variable defined in the main body of a script. Accessible **anywhere**.
*   **Local Scope:** A variable defined inside a function. Accessible **only within that function**.

**Best Practice:** Avoid modifying global variables from inside functions. Pass data in via parameters and return results.
"""

# Global variable
global_message = "I am global 🌎"

def my_function():
    # Local variable
    local_message = "I am local 🏠"
    print(global_message) # Can access global variables
    print(local_message) # Can access local variables

my_function()
print(global_message) # This works
# print(local_message) # This would cause a NameError! ❌

"""### Docstrings: Documenting Your Functions
A **docstring** is a string literal that is the first statement in a function. It explains what the function does, its parameters, and its return value. Essential for professional code!
"""

def calculate_average(numbers):
    """Calculates the average (mean) of a list of numbers.

    Args:
        numbers (list): A list of integers or floats.

    Returns:
        float: The average of the numbers. Returns 0 if the list is empty.
    """
    if not numbers: # Check if the list is empty
        return 0
    total = sum(numbers)
    count = len(numbers)
    return total / count

# Now you can get help on your function!
help(calculate_average)

"""### The `main()` Function Pattern & `if __name__ == "__main__"`
This is a crucial Python idiom for structuring scripts.

*   `def main():` The conventional name for the function that contains your script's primary logic.
*   `if __name__ == "__main__":` This check ensures the code inside it **only runs when the script is executed directly**, not when it's imported as a module by another script.
"""

# This function can be imported by other scripts
def reusable_helper():
    return "I am a helper function!"

# This function contains our main script logic
def main():
    """The main entry point of the script."""
    print("🚀 Script execution started!")
    result = reusable_helper()
    print(result)
    print("✅ Script execution finished.")

# This magic line controls what happens when the file is run
if __name__ == "__main__":
    main()

"""### Handling Command-Line Arguments with `sys.argv`
The `sys.argv` list gives your script access to arguments passed from the command line.
*   `sys.argv[0]`: The name of the script itself.
*   `sys.argv[1]`: The first argument, `sys.argv[2]`: the second, etc.
"""

# Simulating command-line arguments for Colab
# In a real terminal, you'd run: python script.py Alice 30
import sys

# Simulate passing arguments (since we can't in Colab easily)
sys.argv = ["greet.py", "Alice", "30"] # This mimics command-line args

def main():
    print(f"Script name: {sys.argv[0]}")
    if len(sys.argv) > 1:
        name = sys.argv[1]
        print(f"Hello, {name}! 👋")
    if len(sys.argv) > 2:
        age = sys.argv[2]
        print(f"You are {age} years old.")

if __name__ == "__main__":
    main()

"""## 🧪 Hands-On Lab: Refactoring Previous Exercises

Let's apply our new knowledge by refactoring (rewriting) old projects with functions and proper structure.

# 🧮 Task 1: Functional Calculator

## Objective
Create a command-line calculator that uses functions for each operation and handles command-line arguments using `sys.argv`.

## Requirements
1.  **Separate Functions**: Create functions for `add`, `subtract`, `multiply`, and `divide`.
2.  **Command-Line Arguments**: The script should accept three arguments: `num1`, `operation`, `num2`.
3.  **Error Handling**: Handle cases with the wrong number of arguments or invalid operations.
4.  **Main Function**: Use a `main()` function to organize the logic.
5.  **Script Guard**: Use `if __name__ == "__main__":` to prevent execution when imported.

## Example Usage
```bash
python functional_calculator.py 10 + 20
# Output: 10.0 + 20.0 = 30.0
"""

# Refactored Area & Perimeter Calculator with functions
def calculate_area(width, height):
    """Calculates the area of a rectangle."""
    return width * height

def calculate_perimeter(width, height):
    """Calculates the perimeter of a rectangle."""
    return 2 * (width + height)

def main():
    """Main function to run the calculator."""
    print("📏 Rectangle Calculator")
    try:
        w = float(input("Enter the width: "))
        h = float(input("Enter the height: "))
        area = calculate_area(w, h)
        perimeter = calculate_perimeter(w, h)
        print(f"Area: {area}")
        print(f"Perimeter: {perimeter}")
    except ValueError:
        print("❌ Please enter valid numbers!")

if __name__ == "__main__":
    main()

"""# ✅ Task 2: Functional To-Do List

## Objective
Refactor the previous to-do list application using functions and proper program structure.

## Requirements
1.  **Separate Functions**: Create functions for `display_tasks`, `add_task`, and `remove_task`.
2.  **Main Function**: Use a `main()` function containing the main menu loop.
3.  **Script Guard**: Use `if __name__ == "__main__":` to prevent execution when imported.
4.  **Global Data**: Use a global list to store tasks (for this simple implementation).

## Features
- Add tasks to the list
- View all tasks with numbering
- Remove tasks by number
- Continuous operation until user chooses to quit

## Implementation Plan
1.  Create a global `todo_list` to store tasks.
2.  Define functions for each operation.
3.  Create `main()` with a while loop for the user interface.
4.  Use input() to get user commands.
5.  Call appropriate functions based on user input.
"""

# Refactored To-Do List with functions
todo_list = [] # Our data store

def show_help():
    """Displays help information."""
    print("\n📋 TODO LIST HELP")
    print("Type 'add' to add a task.")
    print("Type 'show' to see your tasks.")
    print("Type 'remove' to delete a task.")
    print("Type 'quit' to exit.\n")

def add_task(task):
    """Adds a task to the list."""
    todo_list.append(task)
    print(f"✅ Added: {task}")

def show_tasks():
    """Displays all tasks."""
    if not todo_list:
        print("Your list is empty! 🎉")
    else:
        print("\nYour TODO List:")
        for index, task in enumerate(todo_list, start=1):
            print(f"{index}. {task}")

def remove_task(index):
    """Removes a task by its number."""
    try:
        index = int(index) - 1 # Convert to 0-based index
        removed_task = todo_list.pop(index)
        print(f"❌ Removed: {removed_task}")
    except (ValueError, IndexError):
        print("❌ Invalid task number.")

# The main control loop would be inside a main() function
def main():
    show_help()
    while True:
        user_action = input("What would you like to do? ").strip().lower()
        if user_action == 'quit':
            print("👋 Goodbye!")
            break
        elif user_action == 'add':
            task = input("Enter a task: ")
            add_task(task)
        elif user_action == 'show':
            show_tasks()
        elif user_action == 'remove':
            show_tasks()
            task_num = input("Enter the number of the task to remove: ")
            remove_task(task_num)
        else:
            print("❌ Unknown command. Type 'help' for options.")

if __name__ == "__main__":
    main()