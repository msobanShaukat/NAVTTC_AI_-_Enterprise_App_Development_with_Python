# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#3_L#14_(Date:04-Sept-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11ZawAcqPQJbaJYeONuW25xtjbqAx9dvG

# 🗄️ Module 1: Core Python & Data - Week 3 Lecture 14
**Date:** 04/09/2025  
**Documented by:** Muhammad Soban Shaukat  

## 💾 Beyond Files: Introduction to SQL & Relational Databases

Welcome back! We've learned to save our data in files like `.txt` and `.json`. This is great for simple applications, but what happens when our data becomes large and interconnected?

What if we're building a social media app, an e-commerce store, or a blog? Today, we learn the industry-standard solution for managing structured data: **Relational Databases** and the language we use to talk to them, **SQL**.

## 📋 Today's Agenda

1.  **🤔 The "Why" - What is a Database?**
    *   The Problem with Flat Files
    *   The Three Evils of Flat Data
    *   The Relational Solution

2.  **🏗️ Core Concepts of Relational Databases**
    *   Tables, Rows, Columns, and Keys
    *   Database Design: A Simple Blog Schema

3.  **📊 Exploring the SQL Language**
    *   `SELECT` & `FROM` Statements
    *   `WHERE` Clause for Filtering
    *   `ORDER BY` Clause for Sorting

4.  **🧪 Putting It All Together & Hands-On Lab**
    *   Hands-On Lab: Querying a Sample Database
    *   Bonus Challenges

## 1. 🤔 The "Why" - What is a Database?

### 📊 The Problem with Flat Files

Imagine we're running a small online store and we track our orders in a single spreadsheet (or a big JSON file). This approach is called using "flat files."
"""

# Let's simulate the flat file problem with Python data structures
print("🛒 Flat File Approach: Online Store Orders")
print("=" * 45)

# This represents data stored in a CSV/JSON file
orders_flat = [
    {"OrderID": 101, "OrderDate": "2025-09-05", "CustomerName": "Alice Smith",
     "CustomerEmail": "alice@example.com", "Item": "T-Shirt", "Price": 20.00},
    {"OrderID": 102, "OrderDate": "2025-09-05", "CustomerName": "Bob Johnson",
     "CustomerEmail": "bob@example.com", "Item": "Coffee Mug", "Price": 15.00},
    {"OrderID": 103, "OrderDate": "2025-09-06", "CustomerName": "Alice Smith",
     "CustomerEmail": "alice@example.com", "Item": "Hat", "Price": 25.00},
    {"OrderID": 104, "OrderDate": "2025-09-06", "CustomerName": "Alice Smith",
     "CustomerEmail": "alice.mnih@work.com", "Item": "T-Shirt", "Price": 20.00}
]

# Display the flat data
print("📋 Orders Flat File:")
print("-" * 60)
print(f"{'OrderID':<8} {'Date':<12} {'Customer':<15} {'Email':<20} {'Item':<12} {'Price':<6}")
print("-" * 60)
for order in orders_flat:
    print(f"{order['OrderID']:<8} {order['OrderDate']:<12} {order['CustomerName']:<15} "
          f"{order['CustomerEmail']:<20} {order['Item']:<12} ${order['Price']:<5.2f}")

"""### 😈 The Three Evils of "Flat" Data

This flat file approach seems simple, but it's hiding three major problems:
"""

# Demonstrate the three problems with flat files
print("\n😈 THREE EVILS OF FLAT DATA")
print("=" * 35)

# 1. Data Duplication
print("\n1. 📝 DATA DUPLICATION:")
print("   Alice Smith's information appears 3 times!")
print("   Wastes space and is inefficient.")

# 2. Data Inconsistency (Update Anomaly)
print("\n2. 🔄 DATA INCONSISTENCY (Update Anomaly):")
print("   Order 104 has different email: alice.mnih@work.com")
print("   Is this a typo or an update?")
print("   To fix, we'd need to update ALL Alice's records manually!")

# 3. Data Integrity Issues (Deletion Anomaly)
print("\n3. 🗑️ DATA INTEGRITY (Deletion Anomaly):")
print("   If we delete Bob's order (102), we lose ALL information about Bob!")
print("   We wouldn't even know he was ever a customer!")

"""### 🏗️ The Relational Solution: Smart Tables

A **relational database** solves this by breaking the data into separate, single-purpose tables that can be linked together.
"""

# Show the relational database solution
print("\n🏗️ RELATIONAL DATABASE SOLUTION")
print("=" * 40)

# Customers Table
customers = [
    {"CustomerID": 1, "Name": "Alice Smith", "Email": "alice@example.com"},
    {"CustomerID": 2, "Name": "Bob Johnson", "Email": "bob@example.com"}
]

# Orders Table
orders = [
    {"OrderID": 101, "OrderDate": "2025-09-05", "CustomerID": 1, "Item": "T-Shirt", "Price": 20.00},
    {"OrderID": 102, "OrderDate": "2025-09-05", "CustomerID": 2, "Item": "Coffee Mug", "Price": 15.00},
    {"OrderID": 103, "OrderDate": "2025-09-06", "CustomerID": 1, "Item": "Hat", "Price": 25.00},
    {"OrderID": 104, "OrderDate": "2025-09-06", "CustomerID": 1, "Item": "T-Shirt", "Price": 20.00}
]

print("📊 CUSTOMERS TABLE:")
print("-" * 50)
print(f"{'CustomerID':<12} {'Name':<15} {'Email':<20}")
print("-" * 50)
for customer in customers:
    print(f"{customer['CustomerID']:<12} {customer['Name']:<15} {customer['Email']:<20}")

print("\n📊 ORDERS TABLE:")
print("-" * 60)
print(f"{'OrderID':<8} {'Date':<12} {'CustomerID':<12} {'Item':<12} {'Price':<6}")
print("-" * 60)
for order in orders:
    print(f"{order['OrderID']:<8} {order['OrderDate']:<12} {order['CustomerID']:<12} "
          f"{order['Item']:<12} ${order['Price']:<5.2f}")

print("\n✅ BENEFITS:")
print("   - No data duplication (Alice's info stored once)")
print("   - No inconsistency (Single source of truth)")
print("   - No data loss (Delete order ≠ delete customer)")

"""## 2. 🏗️ Core Concepts of Relational Databases

### 📋 Tables, Rows, and Columns

Imagine a digital filing cabinet designed for perfect organization. A relational database stores data in a structured way using:

- **Table:** A collection of related data, like a spreadsheet
- **Columns:** The headers that define data categories (e.g., CustomerName, City)
- **Rows:** Individual records in the table
"""

# Visualize table structure
print("📋 DATABASE TABLE STRUCTURE")
print("=" * 40)

# Sample Customers table data
customers_data = [
    {"CustomerID": 1, "CustomerName": "Alfreds Futterkiste", "City": "Berlin"},
    {"CustomerID": 2, "CustomerName": "Ana Trujillo", "City": "México D.F."},
    {"CustomerID": 3, "CustomerName": "Antonio Moreno", "City": "México D.F."},
    {"CustomerID": 4, "CustomerName": "Thomas Hardy", "City": "London"}
]

print("CUSTOMERS TABLE:")
print("-" * 50)
print(f"{'CustomerID':<12} {'CustomerName':<25} {'City':<15}")
print("-" * 50)
for customer in customers_data:
    print(f"{customer['CustomerID']:<12} {customer['CustomerName']:<25} {customer['City']:<15}")

print("\n🔑 TABLE COMPONENTS:")
print("   - Columns: CustomerID, CustomerName, City")
print("   - Rows: Each customer record")
print("   - Table: Collection of all customer data")

"""### 🔑 Keys: Primary & Foreign Keys

Keys are special columns essential for identifying rows and linking tables together:

- **Primary Key (PK):** A column with a unique value for every row (like a Student ID)
- **Foreign Key (FK):** A column in one table that refers to the Primary Key of another table
"""

# Demonstrate keys with Authors and Books example
print("🔑 PRIMARY AND FOREIGN KEYS")
print("=" * 40)

# Authors Table
authors = [
    {"AuthorID": 1, "AuthorName": "J.K. Rowling", "Nationality": "British"},
    {"AuthorID": 2, "AuthorName": "George Orwell", "Nationality": "British"}
]

# Books Table
books = [
    {"BookID": 10, "Title": "Harry Potter", "AuthorID": 1},
    {"BookID": 102, "Title": "1984", "AuthorID": 2},
    {"BookID": 103, "Title": "Animal Farm", "AuthorID": 2}
]

print("📚 AUTHORS TABLE (Primary Key: AuthorID):")
print("-" * 55)
print(f"{'AuthorID':<10} {'AuthorName':<15} {'Nationality':<12}")
print("-" * 55)
for author in authors:
    print(f"{author['AuthorID']:<10} {author['AuthorName']:<15} {author['Nationality']:<12}")

print("\n📖 BOOKS TABLE (Primary Key: BookID, Foreign Key: AuthorID):")
print("-" * 45)
print(f"{'BookID':<8} {'Title':<15} {'AuthorID':<10}")
print("-" * 45)
for book in books:
    print(f"{book['BookID']:<8} {book['Title']:<15} {book['AuthorID']:<10}")

print("\n🎯 KEYS EXPLAINED:")
print("   - Authors.AuthorID: PRIMARY KEY (Unique author identifier)")
print("   - Books.BookID: PRIMARY KEY (Unique book identifier)")
print("   - Books.AuthorID: FOREIGN KEY (Links to Authors.AuthorID)")

"""### 🧠 In-Class Exercise: Identifying Keys

Look at the tables above:
1. What is the Primary Key of the Authors table?
2. What is the Primary Key of the Books table?
3. What is the Foreign Key in this schema, and which table is it in?
"""

# Exercise solution
print("🧠 EXERCISE SOLUTION:")
print("=" * 25)
print("1. Primary Key of Authors table: AuthorID")
print("2. Primary Key of Books table: BookID")
print("3. Foreign Key: AuthorID in Books table (links to Authors.AuthorID)")

"""### 🏗️ Database Design: A Simple Blog Schema

Let's apply these concepts to design a database for a simple blog. We need to store information about:
- **Users:** People who write posts and comments
- **Posts:** Articles on the blog  
- **Comments:** Replies to the posts
"""

# Blog database schema design
print("🏗️ BLOG DATABASE SCHEMA DESIGN")
print("=" * 35)

print("📊 USERS TABLE:")
print("   - UserID (Primary Key)")
print("   - Username")
print("   - Email")
print()

print("📝 POSTS TABLE:")
print("   - PostID (Primary Key)")
print("   - Title")
print("   - Content")
print("   - UserID (Foreign Key - links to Users.UserID)")
print()

print("💬 COMMENTS TABLE:")
print("   - CommentID (Primary Key)")
print("   - CommentText")
print("   - PostID (Foreign Key - links to Posts.PostID)")
print("   - UserID (Foreign Key - links to Users.UserID)")
print()

print("🔗 RELATIONSHIPS:")
print("   - One User can have Many Posts (1:M)")
print("   - One Post can have Many Comments (1:M)")
print("   - One User can have Many Comments (1:M)")

# Visualize the relationships with sample data
print("🔗 VISUALIZING RELATIONSHIPS")
print("=" * 35)

# Sample data
users = [
    {"UserID": 1, "Username": "alice_dev", "Email": "alice@example.com"},
    {"UserID": 2, "Username": "bob_writer", "Email": "bob@example.com"}
]

posts = [
    {"PostID": 101, "Title": "Python Basics", "UserID": 1},
    {"PostID": 102, "Title": "SQL Introduction", "UserID": 2}
]

comments = [
    {"CommentID": 1001, "CommentText": "Great post!", "PostID": 101, "UserID": 2},
    {"CommentID": 1002, "CommentText": "Very helpful", "PostID": 101, "UserID": 1},
    {"CommentID": 1003, "CommentText": "Thanks for sharing", "PostID": 102, "UserID": 1}
]

print("👥 USERS:")
for user in users:
    print(f"   {user['UserID']}: {user['Username']}")

print("\n📝 POSTS (with author):")
for post in posts:
    author = next(user for user in users if user['UserID'] == post['UserID'])
    print(f"   {post['PostID']}: '{post['Title']}' by {author['Username']}")

print("\n💬 COMMENTS (on posts by users):")
for comment in comments:
    post = next(p for p in posts if p['PostID'] == comment['PostID'])
    user = next(u for u in users if u['UserID'] == comment['UserID'])
    print(f"   '{comment['CommentText']}' by {user['Username']} on '{post['Title']}'")

"""## 3. 📊 Exploring the SQL Language

**SQL (Structured Query Language)** is the language we use to communicate with relational databases. Let's learn the basic commands!
"""

# Since we're in Colab, we'll use SQLite in Python to run actual SQL queries
import sqlite3
import pandas as pd

# Create an in-memory SQLite database
conn = sqlite3.connect(':memory:')
cursor = conn.cursor()

# Create sample tables
cursor.executescript('''
CREATE TABLE Customers (
    CustomerID INTEGER PRIMARY KEY,
    CustomerName TEXT,
    ContactName TEXT,
    City TEXT,
    Country TEXT
);

CREATE TABLE Products (
    ProductID INTEGER PRIMARY KEY,
    ProductName TEXT,
    Price REAL,
    Category TEXT
);

CREATE TABLE Suppliers (
    SupplierID INTEGER PRIMARY KEY,
    SupplierName TEXT,
    Country TEXT
);
''')

# Insert sample data
cursor.executescript('''
INSERT INTO Customers VALUES
(1, 'Alfreds Futterkiste', 'Maria Anders', 'Berlin', 'Germany'),
(2, 'Ana Trujillo', 'Ana Trujillo', 'México D.F.', 'Mexico'),
(3, 'Antonio Moreno', 'Antonio Moreno', 'México D.F.', 'Mexico'),
(4, 'Around the Horn', 'Thomas Hardy', 'London', 'UK'),
(5, 'Berglunds snabbköp', 'Christina Berglund', 'Luleå', 'Sweden');

INSERT INTO Products VALUES
(1, 'Chais', 18.00, 'Beverages'),
(2, 'Chang', 19.00, 'Beverages'),
(3, 'Aniseed Syrup', 10.00, 'Condiments'),
(4, 'Chef Anton''s Cajun Seasoning', 22.00, 'Condiments'),
(5, 'Chef Anton''s Gumbo Mix', 21.35, 'Condiments'),
(6, 'Grandma''s Boysenberry Spread', 25.00, 'Condiments'),
(7, 'Uncle Bob''s Organic Dried Pears', 30.00, 'Produce'),
(8, 'Northwoods Cranberry Sauce', 40.00, 'Condiments');

INSERT INTO Suppliers VALUES
(1, 'Exotic Liquid', 'UK'),
(2, 'New Orleans Cajun Delights', 'USA'),
(3, 'Grandma Kelly''s Homestead', 'USA'),
(4, 'Tokyo Traders', 'Japan'),
(5, 'Cooperativa de Quesos ''Las Cabras''', 'Spain');
''')

conn.commit()

print("✅ Sample database created with:")
print("   - Customers table (5 records)")
print("   - Products table (8 records)")
print("   - Suppliers table (5 records)")

"""### 🔍 Basic SQL: `SELECT` and `FROM`

These are the two mandatory parts of any query to retrieve data:

- `SELECT`: Chooses which columns you want to see
- `FROM`: Specifies which table to look in
"""

# Example 1: SELECT specific columns
print("🔍 BASIC SQL: SELECT AND FROM")
print("=" * 35)

print("Query: SELECT CustomerName, City FROM Customers;")
print("Translation: Show me CustomerName and City from Customers table")
print()

# Execute query
query1 = "SELECT CustomerName, City FROM Customers;"
result1 = pd.read_sql_query(query1, conn)
print(result1.to_string(index=False))

# Example 2: SELECT all columns
print("\nQuery: SELECT * FROM Customers;")
print("Translation: Show me ALL columns from Customers table")
print()

query2 = "SELECT * FROM Customers;"
result2 = pd.read_sql_query(query2, conn)
print(result2.to_string(index=False))

"""### 🔍 Basic SQL: `WHERE` Clause

The `WHERE` clause filters your rows based on a specific condition:
"""

# WHERE clause examples
print("\n🔍 BASIC SQL: WHERE CLAUSE")
print("=" * 35)

print("Query: SELECT * FROM Customers WHERE Country = 'Germany';")
print("Translation: Show German customers only")
print()

query3 = "SELECT * FROM Customers WHERE Country = 'Germany';"
result3 = pd.read_sql_query(query3, conn)
print(result3.to_string(index=False))

# Multiple conditions with AND/OR
print("\nQuery: SELECT * FROM Customers WHERE Country = 'Mexico' AND City = 'México D.F.';")
print("Translation: Show customers from Mexico City only")
print()

query4 = "SELECT * FROM Customers WHERE Country = 'Mexico' AND City = 'México D.F.';"
result4 = pd.read_sql_query(query4, conn)
print(result4.to_string(index=False))

"""### 🔍 Basic SQL: `ORDER BY` Clause

The `ORDER BY` clause sorts your final results:
"""

# ORDER BY examples
print("\n🔍 BASIC SQL: ORDER BY CLAUSE")
print("=" * 35)

print("Query: SELECT CustomerName, City FROM Customers ORDER BY CustomerName;")
print("Translation: Show customers sorted alphabetically by name")
print()

query5 = "SELECT CustomerName, City FROM Customers ORDER BY CustomerName;"
result5 = pd.read_sql_query(query5, conn)
print(result5.to_string(index=False))

# ORDER BY with descending sort
print("\nQuery: SELECT CustomerName, City FROM Customers ORDER BY CustomerName DESC;")
print("Translation: Show customers sorted in reverse alphabetical order")
print()

query6 = "SELECT CustomerName, City FROM Customers ORDER BY CustomerName DESC;"
result6 = pd.read_sql_query(query6, conn)
print(result6.to_string(index=False))

"""## 4. 🧪 Hands-On Lab: Querying a Sample Database

Now let's practice with more realistic queries using our sample database.
"""

# Hands-on lab exercises
print("🧪 HANDS-ON LAB: SQL QUERY PRACTICE")
print("=" * 40)

# Exercise 1: Get all products with prices
print("1. 📋 Get all products with names and prices:")
query7 = "SELECT ProductName, Price FROM Products;"
result7 = pd.read_sql_query(query7, conn)
print(result7.to_string(index=False))
print()

# Exercise 2: Filter by country
print("2. 🌍 Find all customers from Germany:")
query8 = "SELECT CustomerName, City FROM Customers WHERE Country = 'Germany';"
result8 = pd.read_sql_query(query8, conn)
print(result8.to_string(index=False))
print()

# Exercise 3: Sort suppliers alphabetically
print("3. 🔤 Get all suppliers sorted alphabetically:")
query9 = "SELECT SupplierName FROM Suppliers ORDER BY SupplierName;"
result9 = pd.read_sql_query(query9, conn)
print(result9.to_string(index=False))
print()

"""### 🚀 Bonus Challenges

Let's try some more advanced queries!
"""

# Bonus Challenge 1: Descending order
print("🚀 BONUS CHALLENGE 1: Descending Order")
print("Get suppliers in reverse alphabetical order:")
query10 = "SELECT SupplierName FROM Suppliers ORDER BY SupplierName DESC;"
result10 = pd.read_sql_query(query10, conn)
print(result10.to_string(index=False))
print()

# Bonus Challenge 2: Pattern matching with LIKE
print("🚀 BONUS CHALLENGE 2: Pattern Matching")
print("Find products containing 'Chef' in name:")
query11 = "SELECT ProductName, Price FROM Products WHERE ProductName LIKE '%Chef%';"
result11 = pd.read_sql_query(query11, conn)
print(result11.to_string(index=False))
print()

print("📝 LIKE OPERATOR EXPLANATION:")
print("   - %Chef% means 'contains Chef anywhere'")
print("   - Chef% means 'starts with Chef'")
print("   - %Chef means 'ends with Chef'")

# More advanced queries for practice
print("🎯 EXTRA PRACTICE QUERIES:")
print("=" * 30)

print("1. Products cheaper than $20:")
query12 = "SELECT ProductName, Price FROM Products WHERE Price < 20;"
result12 = pd.read_sql_query(query12, conn)
print(result12.to_string(index=False))
print()

print("2. Beverages category products:")
query13 = "SELECT ProductName, Price FROM Products WHERE Category = 'Beverages';"
result13 = pd.read_sql_query(query13, conn)
print(result13.to_string(index=False))
print()

print("3. Customers not from Germany:")
query14 = "SELECT CustomerName, Country FROM Customers WHERE Country != 'Germany';"
result14 = pd.read_sql_query(query14, conn)
print(result14.to_string(index=False))

# Close the database connection
conn.close()
print("✅ Database connection closed")

"""## 5. 📚 Comprehensive SQL & Databases Summary

### 🎯 What We Learned:

1.  **Database Fundamentals:** Why we need databases instead of flat files
2.  **Relational Concepts:** Tables, rows, columns, primary keys, foreign keys
3.  **Database Design:** How to structure data with relationships
4.  **SQL Basics:** `SELECT`, `FROM`, `WHERE`, `ORDER BY` clauses
5.  **Practical Skills:** Writing and executing SQL queries

### 🔑 Key Concepts:

- **Normalization:** Eliminating data redundancy through proper table design
- **Relationships:** Linking tables through primary and foreign keys
- **SQL Syntax:** The language for interacting with databases
- **Data Integrity:** Maintaining accurate and consistent data

### 💡 Real-world Applications:

- **E-commerce:** Customer orders, product catalogs, inventory
- **Social Media:** User profiles, posts, comments, likes
- **Blogging:** Articles, authors, categories, tags
- **Business Systems:** Employees, departments, projects

### 🚀 Best Practices:

1.  **Use meaningful table and column names**
2.  **Always define primary keys**
3.  **Use foreign keys to enforce relationships**
4.  **Normalize data to avoid duplication**
5.  **Use `WHERE` clauses to filter data efficiently**
6.  **Test queries before using them in production**

### 📊 SQL Clause Summary:

| Clause | Purpose | Example |
|:-------|:--------|:--------|
| **SELECT** | Choose columns to display | `SELECT name, age` |
| **FROM** | Specify table to query | `FROM users` |
| **WHERE** | Filter rows based on conditions | `WHERE age > 18` |
| **ORDER BY** | Sort results | `ORDER BY name DESC` |

### ✅ Completion Checklist:

- [x] Understand the problems with flat file storage
- [x] Learn relational database concepts (tables, keys, relationships)
- [x] Design a simple database schema
- [x] Write basic SQL queries with `SELECT`, `FROM`
- [x] Use `WHERE` clause for filtering data
- [x] Use `ORDER BY` clause for sorting results
- [x] Practice with pattern matching using `LIKE`
- [x] Complete hands-on lab exercises

### 🔮 Next Steps:

1.  **Learn advanced SQL:** `JOIN`, `GROUP BY`, `HAVING`, aggregate functions
2.  **Explore database management systems:** MySQL, PostgreSQL, SQL Server
3.  **Learn about indexes** for performance optimization
4.  **Study database normalization** forms
5.  **Practice with real-world datasets**
6.  **Learn about ORMs** (Object-Relational Mappers) for Python

This foundation in SQL and relational databases will enable you to build robust, scalable applications that can handle complex data relationships efficiently! 🗄️
"""