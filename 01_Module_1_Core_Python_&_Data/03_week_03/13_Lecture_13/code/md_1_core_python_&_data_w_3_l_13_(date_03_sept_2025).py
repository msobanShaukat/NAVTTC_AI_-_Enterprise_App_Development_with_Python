# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#3_L#13_(Date:03-Sept-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12XezK0OxkHIQlUW96cYOd0ybfqc1RrQ5

# 🏝️ Module 1: Core Python & Data - Week 3 Lecture 13
**Date:** 03/09/2025  
**Documented By:** Muhammad Soban Shaukat

## 🛠️ The Developer's Sandbox: Mastering Virtual Environments

Welcome back! We've learned to use powerful modules, but a new problem arises: how do we manage these external tools? What happens if one project needs an old version of a library, and another project needs a new version? Today, we learn the single most important practice for professional Python development: **virtual environments**.

## 📋 Today's Agenda

1.  **🤔 The "Why" & The Environment Lifecycle**
    *   The Global Mess & The Dependency Problem
    *   The Solution: Isolated Environments with Conda
    *   The Basic Conda Workflow: Create, Activate, Deactivate
    *   Advanced Environment Management: List, Clone, Rename, Remove

2.  **🛠️ The "How" - Managing Dependencies**
    *   `conda install` vs. `pip install`: Which to Use?
    *   Reproducibility: The `environment.yml` File
    *   Live Demo: The Power of Isolation with Conda

3.  **🧪 Practical Examples & The Hands-On Lab**
    *   Real-World Scenarios: Web Dev, Data Science, AI
    *   Conda Environment Management Cheat Sheet
    *   Hands-On Lab: Project Setup with `requests`
    *   Q&A and Wrap-up

## 1. 🤔 The "Why" - The Dependency Problem

### 🌀 The Global Mess

When you first install Python, there is one central location where all third-party packages are installed. This is called the **global site-packages directory**.

If you just type `pip install <package>`, it goes into this global space.

**The Problem:** Imagine you have two projects:
- **Project A:** An old, stable project that relies on `Report-Generator v1.2`
- **Project B:** A new project that needs the new features in `Report-Generator v2.0`

If you install v2.0 for Project B, you might accidentally break Project A! This is called **Dependency Hell**, and it's a nightmare for developers.
"""

# Demonstration of the dependency problem
# (This is a simulation since we can't show actual global package conflicts in Colab)

print("🐍 SIMULATION: The Dependency Problem")
print("=" * 40)

# Simulate what happens with global packages
print("Initial global state:")
print("- Python 3.9")
print("- Report-Generator v1.2 (for Project A)")
print("- Flask v1.1.2")
print()

print("Installing Report-Generator v2.0 for Project B...")
print("💥 CONFLICT: Project A breaks because it depends on v1.2!")
print("💥 CONFLICT: Flask might also break due to incompatible dependencies!")
print()

print("This is why we need virtual environments! 🏝️")

"""### 🏝️ The Solution: Isolated Environments

A **virtual environment** is a self-contained directory that holds a particular version of Python plus all the packages that a specific project needs. It's like giving each project its own private, isolated workshop.

**Analogy:** Think of it as giving each project its own private, isolated workshop. Project A gets a workshop with all its old, trusted tools. Project B gets a brand-new workshop where it can install the latest and greatest tools. The tools in one workshop don't affect the other.
"""

# Simulation of virtual environments solving the problem
print("🏝️ SOLUTION: Virtual Environments")
print("=" * 40)

print("Project A Environment:")
print("- Python 3.8")
print("- Report-Generator v1.2")
print("- Flask v1.1.2")
print()

print("Project B Environment:")
print("- Python 3.10")
print("- Report-Generator v2.0")
print("- Flask v2.2.0")
print()

print("✅ SUCCESS: Both projects work independently!")
print("✅ NO CONFLICTS: Each has its own isolated space!")

"""## 2. 🔧 Environment Managers: Conda vs Venv

### 🐍 Conda (via Miniconda/Anaconda)

**What it is:** A powerful package and environment manager.

**Key Advantages:**
- **Manages Python Versions:** Conda can install different versions of Python itself (e.g., 3.8, 3.9, 3.10) in different environments
- **Manages Non-Python Dependencies:** Crucial for AI/Data Science, as it can install complex libraries like CUDA and MKL
- **Robust Dependency Resolution:** Powerful solver to handle complex package dependencies

### 📦 Venv (The Built-in Alternative)

**What it is:** A lightweight environment manager included with Python.

**How it's different:** It can only create environments with the same Python version used to create them. It cannot manage non-Python packages. Great for simple, pure-Python web applications.
"""

# Comparison table simulation
print("🆚 Conda vs Venv Comparison")
print("=" * 30)

comparison_data = [
    ["Feature", "Conda", "Venv"],
    ["Python Version Management", "✅ Yes", "❌ No"],
    ["Non-Python Packages", "✅ Yes", "❌ No"],
    ["Dependency Resolution", "✅ Advanced", "✅ Basic"],
    ["Built-in with Python", "❌ No", "✅ Yes"],
    ["Ideal For", "Data Science, AI", "Web Development"]
]

for row in comparison_data:
    print(f"{row[0]:25} {row[1]:10} {row[2]:10}")

print("\n🎯 For this course, we'll focus on Conda as it's more powerful!")

"""## 3. 🔄 The Basic Conda Workflow

Let's learn the essential commands for managing Conda environments.
"""

# Since we're in Google Colab, we'll simulate Conda commands
# In a real terminal, you would use these commands directly

print("🐍 Conda Command Simulation")
print("=" * 30)

# Simulate Conda commands with output
conda_commands = [
    "# Create an environment",
    "conda create --name my-first-env python=3.9",
    "",
    "# Activate the environment",
    "conda activate my-first-env",
    "# (Your terminal prompt changes to show (my-first-env))",
    "",
    "# Install packages",
    "conda install numpy pandas matplotlib",
    "",
    "# Deactivate the environment",
    "conda deactivate",
    "",
    "# List all environments",
    "conda env list",
    "",
    "# Remove an environment",
    "conda env remove --name my-first-env"
]

for cmd in conda_commands:
    if cmd.startswith("#"):
        print(f"\n📝 {cmd[1:].strip()}")
    elif cmd:
        print(f"$ {cmd}")

"""### 🎯 Essential Conda Commands:

1.  **Create environment:** `conda create --name env_name python=3.9`
2.  **Activate environment:** `conda activate env_name`
3.  **Install package:** `conda install package_name`
4.  **Deactivate environment:** `conda deactivate`
5.  **List environments:** `conda env list`
6.  **Remove environment:** `conda env remove --name env_name`

## 4. 🎩 Advanced Environment Management

### 📋 Cloning (Duplicating) Environments

This is an incredibly useful feature. Cloning creates an exact copy of an existing environment under a new name.

**Why do this?** Imagine you have a stable, working environment for a project (`my_project_stable`). You want to test a new, potentially breaking version of a library. Instead of risking your stable environment, you clone it!
"""

# Simulate environment cloning
print("🌀 Environment Cloning Workflow")
print("=" * 35)

print("1. Create stable environment:")
print("   $ conda create --name my_project_stable python=3.9 pandas=1.5")
print()

print("2. Clone for testing:")
print("   $ conda create --name my_project_testing --clone my_project_stable")
print()

print("3. Test new version safely:")
print("   $ conda activate my_project_testing")
print("   $ conda install pandas=2.0")
print()

print("4. If it breaks, just delete the test environment:")
print("   $ conda env remove --name my_project_testing")
print()

print("5. Your stable environment remains untouched! ✅")

"""### 🔄 Other Advanced Operations:

- **Renaming environments:** Clone with new name + delete old one
- **Exporting environments:** `conda env export > environment.yml`
- **Creating from file:** `conda env create -f environment.yml`
- **Updating environments:** `conda update --all`

## 5. 📦 Managing Dependencies with Conda

### 🔄 conda install vs. pip install

Inside a Conda environment, you can use both. Here's the rule of thumb:

1.  **Always try `conda install <package>` first** - Uses Anaconda's tested, pre-compiled packages
2.  **If not available, use `pip install <package>`** - Installs from PyPI

### 💾 Reproducibility: The environment.yml File

This is the Conda equivalent of `requirements.txt`, but it's more powerful. It saves the environment's name, channels, Python version, and all package dependencies.
"""

# Simulate environment.yml creation and usage
print("📁 environment.yml File Example")
print("=" * 35)

environment_yml_content = """
name: my-data-science-project
channels:
  - conda-forge
  - defaults
dependencies:
  - python=3.9
  - numpy=1.21
  - pandas=1.5
  - matplotlib=3.5
  - scikit-learn=1.0
  - pip
  - pip:
    - some-pypi-only-package==1.2.3
"""

print("To save your environment:")
print("$ conda env export > environment.yml")
print()
print("Generated environment.yml content:")
print(environment_yml_content)
print()
print("To recreate environment from file:")
print("$ conda env create -f environment.yml")

"""## 6. 🎬 Live Demo: The Power of Isolation with Conda

Let's simulate the Flask project example to demonstrate environment isolation.
"""

# Simulation of the Flask project demo
print("🎭 SIMULATION: Flask Project Isolation Demo")
print("=" * 45)

print("📁 Project Structure:")
print("project_old/")
print("├── app_old.py (Flask 1.x, Python 3.8)")
print("└── environment.yml")
print()
print("project_new/")
print("├── app_new.py (Flask 2.x, Python 3.10)")
print("└── environment.yml")
print()

print("🚀 Setting up Project OLD:")
print("$ conda create --name old_flask python=3.8 flask=1.1")
print("$ conda activate old_flask")
print("$ python app_old.py")
print()

print("🚀 Setting up Project NEW:")
print("$ conda create --name new_flask python=3.10 flask=2.2")
print("$ conda activate new_flask")
print("$ python app_new.py")
print()

print("✅ BOTH PROJECTS WORK SIMULTANEOUSLY!")
print("✅ NO VERSION CONFLICTS!")
print("✅ PERFECT ISOLATION ACHIEVED! 🏝️")

# Let's create the actual Flask app files to see the code difference
print("🖥️ Flask App Code Comparison")
print("=" * 35)

print("Project OLD (app_old.py):")
old_flask_code = """
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello from OLD Flask (v1.x) on Python 3.8!"
"""

print(old_flask_code)

print("Project NEW (app_new.py):")
new_flask_code = """
from flask import Flask
app = Flask(__name__)

@app.get("/")  # Modern syntax introduced in Flask 2.0
def hello():
    return "Hello from NEW Flask (v2.x) on Python 3.10!"
"""

print(new_flask_code)

"""## 7. 📋 Conda Environment Management Cheat Sheet

Here's a quick reference for all the essential Conda commands:
"""

# Conda Cheat Sheet
print("📋 Conda Cheat Sheet")
print("=" * 25)

cheat_sheet = [
    ["Task", "Command"],
    ["Create environment", "conda create --name env_name python=3.9"],
    ["Activate environment", "conda activate env_name"],
    ["Deactivate environment", "conda deactivate"],
    ["List environments", "conda env list"],
    ["Install package", "conda install package_name"],
    ["List installed packages", "conda list"],
    ["Clone environment", "conda create --name new_env --clone old_env"],
    ["Remove environment", "conda env remove --name env_name"],
    ["Export environment", "conda env export > environment.yml"],
    ["Create from file", "conda env create -f environment.yml"],
    ["Update all packages", "conda update --all"],
    ["Search for package", "conda search package_name"]
]

for task, command in cheat_sheet:
    print(f"{task:25} {command}")

"""## 8. 🧪 Hands-On Lab: Project Setup with Requests

**Goal:** Go through the full professional Conda workflow: create a project, set up an environment, install a package, write a script, and generate an environment.yml file.

**The Project:** We'll write a simple script that uses the `requests` library to fetch data from a public API.
"""

# Since we're in Colab, we'll simulate the Conda workflow
# But we can actually write and run the Python code!

print("🧪 Hands-On Lab: API Project")
print("=" * 35)

print("Step 1: Create project directory")
print("$ mkdir api_project && cd api_project")
print()

print("Step 2: Create and activate Conda environment")
print("$ conda create --name api_project python=3.9 requests")
print("$ conda activate api_project")
print()

print("Step 3: Write the Python script (fetch_data.py)")

# Step 3: Write the actual Python script
# We can do this part for real in Colab!

import requests
import json

def fetch_api_data():
    """Fetch data from a public API using requests."""
    print("🌐 Fetching data from JSONPlaceholder API...")

    try:
        # Using JSONPlaceholder - a free fake API for testing
        response = requests.get('https://jsonplaceholder.typicode.com/posts/1')
        response.raise_for_status()  # Raise exception for bad status codes

        data = response.json()

        print("✅ Successfully fetched data!")
        print("\n📄 API Response:")
        print(json.dumps(data, indent=2))

        # Extract specific information
        print(f"\n📋 Extracted Info:")
        print(f"Title: {data['title']}")
        print(f"User ID: {data['userId']}")
        print(f"Post ID: {data['id']}")

        return data

    except requests.exceptions.RequestException as e:
        print(f"❌ Error fetching data: {e}")
        return None

# Run the function
if __name__ == "__main__":
    fetch_api_data()

# Run the script (in Colab, we can actually execute this)
print("Step 4: Run the script")
print("$ python fetch_data.py")
print()

# Actually run our function
fetch_api_data()

# Step 5: Generate environment.yml file
print("Step 5: Generate environment.yml")
print("$ conda env export > environment.yml")
print()

# Simulate what the environment.yml would look like
simulated_environment_yml = """
name: api_project
channels:
  - conda-forge
  - defaults
dependencies:
  - python=3.9.12
  - requests=2.28.0
  - certifi=2022.9.24
  - urllib3=1.26.12
  - idna=3.4
  - charset-normalizer=2.1.1
  - openssl=1.1.1q
prefix: /opt/anaconda3/envs/api_project
"""

print("Generated environment.yml would contain:")
print(simulated_environment_yml)

"""## 9. 🌍 Real-World Scenarios

Different types of projects have different environment needs:
"""

# Real-world environment examples
print("🌍 Real-World Environment Examples")
print("=" * 35)

scenarios = [
    {
        "type": "Web Development",
        "python": "3.10",
        "packages": ["flask==2.2.0", "requests==2.28.0", "sqlalchemy==1.4.41"],
        "purpose": "Web applications with modern frameworks"
    },
    {
        "type": "Data Science",
        "python": "3.9",
        "packages": ["pandas==1.5.0", "numpy==1.23.0", "matplotlib==3.6.0", "scikit-learn==1.1.0"],
        "purpose": "Data analysis and machine learning"
    },
    {
        "type": "AI/Deep Learning",
        "python": "3.8",
        "packages": ["tensorflow==2.10.0", "torch==1.12.0", "transformers==4.24.0"],
        "purpose": "Neural networks and deep learning models"
    }
]

for scenario in scenarios:
    print(f"\n📊 {scenario['type']}:")
    print(f"   Python: {scenario['python']}")
    print(f"   Packages: {', '.join(scenario['packages'][:3])}...")
    print(f"   Purpose: {scenario['purpose']}")

"""## 10. 📚 Comprehensive Virtual Environments Summary

### 🎯 What We Learned:

1.  **Dependency Management:** Solving version conflicts with isolated environments
2.  **Conda Workflow:** Create, activate, install, deactivate environments
3.  **Advanced Features:** Cloning, exporting, and reproducing environments
4.  **Professional Practices:** Using `environment.yml` for reproducibility

### 🔑 Key Concepts:

- **Isolation:** Each project gets its own environment
- **Reproducibility:** `environment.yml` files ensure consistent setups
- **Dependency Resolution:** Conda handles complex package relationships
- **Version Management:** Different Python versions for different projects

### 💡 Real-world Applications:

- **Web Development:** Isolating Flask/Django projects
- **Data Science:** Managing complex scientific computing stacks
- **AI/ML:** Handling GPU-accelerated libraries
- **Testing:** Safe testing of new package versions
- **Collaboration:** Sharing reproducible environments

### 🚀 Best Practices:

1.  **One environment per project**
2.  **Use `environment.yml` for reproducibility**
3.  **Try `conda install` before `pip install`**
4.  **Keep environments focused** (don't install everything in one)
5.  **Regularly update and clean up** unused environments

### ✅ Completion Checklist:

- [x] Understand the dependency problem and solution
- [x] Learn Conda basic commands and workflow
- [x] Practice environment cloning and management
- [x] Create `environment.yml` files for reproducibility
- [x] Build a complete project with proper environment setup
- [x] Understand real-world use cases for different project types

### 🔮 Next Steps:

1.  **Explore Conda channels** (conda-forge, bioconda, etc.)
2.  **Learn about Docker** for even more isolation
3.  **Study continuous integration** with environment setup
4.  **Explore advanced dependency management** tools
5.  **Practice with real projects** to solidify your skills

This foundation in virtual environments will make you a professional Python developer who can manage complex projects without dependency nightmares! 🏝️
"""