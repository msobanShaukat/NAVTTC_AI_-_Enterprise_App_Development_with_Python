# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#4_L#16_(Date:08-Sept-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RaGK0ZpUpxgAWBlH5D3iMc6YLVX3Wbj6

# 🗄️ Module 1: Core Python & Data - Week 4 Lecture 16
**Date:** 08/09/2025  
**Documented by:** Muhammad Soban Shaukat  

## 🛠️ Python Meets SQL: Building Databases Programmatically

Welcome to Lecture 15! In our previous sessions, we learned SQL fundamentals and how to query databases. Today, we'll learn how to use Python to create and manage SQL databases programmatically. This is a crucial skill for any data professional or developer!

```python
# Setup: Import necessary libraries
import sqlite3
import pandas as pd

print("✅ Libraries imported successfully!")
```

## 📋 Today's Agenda

1.  **🛠️ Setting Up Your Local Workshop**
    *   Installing necessary tools
    *   Verifying your environment

2.  **🐍 Python Meets SQLite: A Simple Example**
    *   Understanding the 4 key steps of database communication
    *   Code breakdown: connect, cursor, execute, commit, and close

3.  **🏗️ Deep Dive: Data Definition Language (DDL)**
    *   CREATE, ALTER, and DROP commands
    *   Building database schemas programmatically

4.  **🧪 Hands-On Lab: Build Your Database in Python**
    *   Creating a complete blog database schema
    *   Bonus challenges for advanced practice

---

## 1. 🛠️ Setting Up Your Local Workshop

### 📥 Download & Install SQLite

While we're working in Google Colab which already has SQLite, here's how you would set it up locally:

1. Go to: https://sqlitebrowser.org/dl/
2. Download and run the standard installer for your OS
3. Follow the setup wizard, keeping the default options

### 🔍 Verify the Installation

In your local environment, you would verify with:

```bash
sqlite3 --version
```

But in Colab, we can check directly:

```python
# Check SQLite version in Colab
import sqlite3
print(f"📊 SQLite version: {sqlite3.version}")
print(f"🗄️ SQLite database version: {sqlite3.sqlite_version}")
```

### 💡 Our Workflow

In this lecture, we'll:
- Write all our code in Python cells
- Create and manipulate SQLite databases programmatically
- Focus on Data Definition Language (DDL) commands

---

## 2. 🐍 Python Meets SQLite: A Simple Example

Let's start with a simple example that shows how Python can interact with SQLite databases.

```python
# Simple Python-SQLite example
print("🐍 PYTHON MEETS SQLITE: SIMPLE EXAMPLE")
print("=" * 45)

# Step 1: Connect to a database (creates if not exists)
conn = sqlite3.connect("test.db")
print("✅ Step 1: Connected to database 'test.db'")

# Step 2: Create a cursor object
cur = conn.cursor()
print("✅ Step 2: Cursor created")

# Step 3: Execute SQL commands
# Create table if it doesn't exist
cur.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)")
print("✅ Step 3: Table 'users' created (if didn't exist)")

# Insert data
cur.execute("INSERT INTO users (name) VALUES (?)", ("Alice",))
print("✅ Data inserted: Added Alice to users table")

# Step 4: Commit changes
conn.commit()
print("✅ Step 4: Changes committed to database")

# Step 5: Query data
cur.execute("SELECT * FROM users")
result = cur.fetchall()
print("✅ Step 5: Data retrieved from database")
print(f"📋 Result: {result}")

# Step 6: Close connection
conn.close()
print("✅ Step 6: Database connection closed")
```

### 🔑 Key Python-SQLite Commands Explained

Let's break down the essential commands:

```python
print("\n🔑 KEY PYTHON-SQLITE COMMANDS")
print("=" * 35)

print("1. sqlite3.connect('database.db')")
print("   - Opens a connection to a database file")
print("   - Creates the file if it doesn't exist")
print("   - 📞 Analogy: Picking up the phone and dialing the database")

print("\n2. conn.cursor()")
print("   - Creates a cursor object to execute SQL commands")
print("   - 📝 Analogy: Getting a messenger to deliver your commands")

print("\n3. cursor.execute(SQL_COMMAND)")
print("   - Executes a single SQL command")
print("   - 💬 Analogy: Giving a specific instruction to the messenger")

print("\n4. conn.commit()")
print("   - Saves all changes permanently to the database")
print("   - 💾 Analogy: Hitting the 'Save' button - crucial step!")

print("\n5. cursor.fetchall() / cursor.fetchone()")
print("   - Retrieves data after a SELECT query")
print("   - 📋 Analogy: Reading the response from the database")

print("\n6. conn.close()")
print("   - Safely closes the database connection")
print("   - 📞 Analogy: Hanging up the phone - good practice!")
```

---

## 3. 🏗️ Deep Dive: Data Definition Language (DDL)

### 📊 What is Data Definition Language (DDL)?

DDL consists of SQL commands that define the database structure. They don't manipulate data itself, but rather the containers that hold data.

```python
print("🏗️ DATA DEFINITION LANGUAGE (DDL)")
print("=" * 40)

print("📚 DDL Commands:")
print("   - CREATE: Builds new tables and structures")
print("   - ALTER: Modifies existing structures")
print("   - DROP: Deletes tables and structures")

print("\n🏠 Analogy:")
print("   If your data is the furniture and people in a house,")
print("   DDL is the construction crew that builds, modifies,")
print("   and demolishes the rooms, walls, and floors.")
```

### 📋 DDL Example 1: The CREATE Statement

The CREATE statement builds new tables from scratch, defining every column and its rules.

```python
# CREATE statement example
print("\n📋 DDL EXAMPLE 1: CREATE STATEMENT")
print("=" * 40)

# Common SQL data types
data_types = {
    "INTEGER": "Whole numbers (e.g., UserID, Age)",
    "TEXT": "Strings (e.g., Username, Email, Description)",
    "REAL": "Decimal numbers (e.g., Price, Rating)",
    "BLOB": "Binary data (e.g., images, files)",
    "NUMERIC": "Exact numeric values (e.g., Decimal, Boolean)"
}

print("📊 COMMON SQL DATA TYPES:")
for dtype, description in data_types.items():
    print(f"   - {dtype}: {description}")

# Essential constraints
constraints = {
    "PRIMARY KEY": "Marks a column as the unique ID for each row",
    "FOREIGN KEY": "Creates a link to a PRIMARY KEY in another table",
    "NOT NULL": "Guarantees a column must have a value",
    "UNIQUE": "Ensures every value in that column is different",
    "DEFAULT": "Provides a default value if none is specified",
    "CHECK": "Ensures values meet specific conditions"
}

print("\n🔒 ESSENTIAL CONSTRAINTS:")
for constraint, description in constraints.items():
    print(f"   - {constraint}: {description}")
```

Let's create a Products table with various constraints:

```python
# Create a new database for DDL examples
ddl_conn = sqlite3.connect("ddl_examples.db")
ddl_cur = ddl_conn.cursor()

# Create Products table with various constraints
create_products_table = '''
CREATE TABLE IF NOT EXISTS Products (
    ProductID INTEGER PRIMARY KEY,
    Name TEXT NOT NULL,
    Price REAL CHECK(Price >= 0),
    SKU TEXT UNIQUE,
    StockQuantity INTEGER DEFAULT 0,
    Category TEXT CHECK(Category IN ('Electronics', 'Clothing', 'Books', 'Other'))
);
'''

ddl_cur.execute(create_products_table)
ddl_conn.commit()
print("✅ Products table created with various constraints!")

# Show table schema
ddl_cur.execute("PRAGMA table_info(Products)")
schema = ddl_cur.fetchall()
print("\n📋 PRODUCTS TABLE SCHEMA:")
print("Column Name | Data Type | Not Null | Default Value | Primary Key")
print("-" * 65)
for column in schema:
    print(f"{column[1]:<12} {column[2]:<10} {column[3]:<9} {str(column[4]):<14} {column[5]}")
```

### 📋 DDL Example 2: The ALTER Statement

The ALTER statement changes the structure of existing tables without deleting them.

```python
# ALTER statement example
print("\n📋 DDL EXAMPLE 2: ALTER STATEMENT")
print("=" * 40)

# Add a new column to the Products table
alter_table = '''
ALTER TABLE Products ADD COLUMN Description TEXT;
'''

ddl_cur.execute(alter_table)
ddl_conn.commit()
print("✅ Added 'Description' column to Products table!")

# Show updated table schema
ddl_cur.execute("PRAGMA table_info(Products)")
schema = ddl_cur.fetchall()
print("\n📋 UPDATED PRODUCTS TABLE SCHEMA:")
print("Column Name | Data Type | Not Null | Default Value | Primary Key")
print("-" * 65)
for column in schema:
    print(f"{column[1]:<12} {column[2]:<10} {column[3]:<9} {str(column[4]):<14} {column[5]}")
```

### 📋 DDL Example 3: The DROP Statement

The DROP statement completely and permanently deletes tables and their data.

```python
# DROP statement example (with safety check)
print("\n📋 DDL EXAMPLE 3: DROP STATEMENT")
print("=" * 40)

# Create a temporary table to demonstrate DROP
ddl_cur.execute("CREATE TABLE IF NOT EXISTS TempTable (id INTEGER, data TEXT)")
ddl_conn.commit()
print("✅ Created temporary table for demonstration")

# Show all tables before DROP
ddl_cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
tables_before = [table[0] for table in ddl_cur.fetchall()]
print(f"📋 Tables before DROP: {tables_before}")

# Drop the temporary table safely
ddl_cur.execute("DROP TABLE IF EXISTS TempTable")
ddl_conn.commit()
print("✅ Dropped TempTable (if it existed)")

# Show all tables after DROP
ddl_cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
tables_after = [table[0] for table in ddl_cur.fetchall()]
print(f"📋 Tables after DROP: {tables_after}")

# Close DDL examples connection
ddl_conn.close()
print("\n✅ Closed DDL examples database connection")
```

---

## 4. 🧪 Hands-On Lab: Build Your Blog Database

Now let's apply what we've learned to build a complete blog database schema!

### 🎯 Goal: Create a Blog Database with Three Tables

We'll create:
1. **Users table**: For blog authors
2. **Posts table**: For blog articles  
3. **Comments table**: For user comments on posts

```python
print("🧪 HANDS-ON LAB: BUILD A BLOG DATABASE")
print("=" * 45)

# Create a new database for our blog
blog_conn = sqlite3.connect("blog.db")
blog_cur = blog_conn.cursor()
print("✅ Connected to blog.db database")
```

### 📋 Step 1: Create the Users Table

```python
# Create Users table
create_users_table = '''
CREATE TABLE IF NOT EXISTS Users (
    UserID INTEGER PRIMARY KEY,
    Username TEXT UNIQUE NOT NULL,
    Email TEXT UNIQUE NOT NULL,
    DateJoined DATETIME DEFAULT CURRENT_TIMESTAMP
);
'''

blog_cur.execute(create_users_table)
blog_conn.commit()
print("✅ Created Users table")

# Show Users table schema
blog_cur.execute("PRAGMA table_info(Users)")
users_schema = blog_cur.fetchall()
print("\n📋 USERS TABLE SCHEMA:")
for column in users_schema:
    print(f"   - {column[1]}: {column[2]}{' (PK)' if column[5] else ''}")
```

### 📋 Step 2: Create the Posts Table

```python
# Create Posts table with foreign key to Users
create_posts_table = '''
CREATE TABLE IF NOT EXISTS Posts (
    PostID INTEGER PRIMARY KEY,
    Title TEXT NOT NULL,
    Content TEXT NOT NULL,
    PublishedDate DATETIME DEFAULT CURRENT_TIMESTAMP,
    AuthorID INTEGER NOT NULL,
    FOREIGN KEY (AuthorID) REFERENCES Users(UserID) ON DELETE CASCADE
);
'''

blog_cur.execute(create_posts_table)
blog_conn.commit()
print("✅ Created Posts table with foreign key to Users")

# Show Posts table schema
blog_cur.execute("PRAGMA table_info(Posts)")
posts_schema = blog_cur.fetchall()
print("\n📋 POSTS TABLE SCHEMA:")
for column in posts_schema:
    print(f"   - {column[1]}: {column[2]}{' (PK)' if column[5] else ''}{' (FK → Users)' if column[1] == 'AuthorID' else ''}")
```

### 📋 Step 3: Create the Comments Table

```python
# Create Comments table with foreign keys to Users and Posts
create_comments_table = '''
CREATE TABLE IF NOT EXISTS Comments (
    CommentID INTEGER PRIMARY KEY,
    CommentText TEXT NOT NULL,
    CommentDate DATETIME DEFAULT CURRENT_TIMESTAMP,
    UserID INTEGER NOT NULL,
    PostID INTEGER NOT NULL,
    FOREIGN KEY (UserID) REFERENCES Users(UserID) ON DELETE CASCADE,
    FOREIGN KEY (PostID) REFERENCES Posts(PostID) ON DELETE CASCADE
);
'''

blog_cur.execute(create_comments_table)
blog_conn.commit()
print("✅ Created Comments table with foreign keys to Users and Posts")

# Show Comments table schema
blog_cur.execute("PRAGMA table_info(Comments)")
comments_schema = blog_cur.fetchall()
print("\n📋 COMMENTS TABLE SCHEMA:")
for column in comments_schema:
    fk_info = ""
    if column[1] == "UserID":
        fk_info = " (FK → Users)"
    elif column[1] == "PostID":
        fk_info = " (FK → Posts)"
    print(f"   - {column[1]}: {column[2]}{' (PK)' if column[5] else ''}{fk_info}")
```

### 📋 Step 4: Verify All Tables Were Created

```python
# Verify all tables were created
blog_cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
tables = blog_cur.fetchall()
print("\n📋 ALL TABLES IN BLOG DATABASE:")
for table in tables:
    print(f"   - {table[0]}")

# Show foreign key relationships
blog_cur.execute("PRAGMA foreign_key_list(Posts)")
post_fks = blog_cur.fetchall()
print("\n🔗 FOREIGN KEY RELATIONSHIPS IN POSTS TABLE:")
for fk in post_fks:
    print(f"   - {fk[3]} → {fk[2]}.{fk[4]}")

blog_cur.execute("PRAGMA foreign_key_list(Comments)")
comment_fks = blog_cur.fetchall()
print("\n🔗 FOREIGN KEY RELATIONSHIPS IN COMMENTS TABLE:")
for fk in comment_fks:
    print(f"   - {fk[3]} → {fk[2]}.{fk[4]}")

# Close blog database connection
blog_conn.close()
print("\n✅ Closed blog database connection")
```

---

## 5. 🚀 Bonus Challenges

### 🎯 Advanced Practice Exercises

Test your skills with these bonus challenges!

```python
print("🚀 BONUS CHALLENGES")
print("=" * 20)
```

**Challenge 1: The "Reply-To" Feature**

```python
print("1. 💬 Add threaded comments (reply-to feature)")
print("=" * 50)

# Create a new database connection for modifications
mod_conn = sqlite3.connect("blog.db")
mod_cur = mod_conn.cursor()

# Add ParentCommentID column for threaded comments
alter_comments_table = '''
ALTER TABLE Comments ADD COLUMN ParentCommentID INTEGER;
'''

mod_cur.execute(alter_comments_table)

# Add foreign key constraint for self-referencing relationship
# Note: SQLite doesn't support adding foreign keys with ALTER TABLE
# So we need to create a new table and copy data

# First, let's see the current structure
mod_cur.execute("PRAGMA table_info(Comments)")
current_schema = mod_cur.fetchall()
print("📋 CURRENT COMMENTS TABLE STRUCTURE:")
for column in current_schema:
    print(f"   - {column[1]}: {column[2]}")

print("\nℹ️  Note: Adding foreign key constraints to existing tables")
print("   requires creating a new table in SQLite. This is more advanced.")
print("   For now, we've added the ParentCommentID column.")

mod_conn.commit()
mod_conn.close()
print("✅ Added ParentCommentID column to Comments table")
```

**Challenge 2: The "Draft" Status**

```python
print("\n2. 📝 Add post status (draft/published) with constraints")
print("=" * 60)

# Reconnect to database
mod_conn = sqlite3.connect("blog.db")
mod_cur = mod_conn.cursor()

# Add Status column with constraints
alter_posts_table = '''
ALTER TABLE Posts ADD COLUMN Status TEXT DEFAULT 'draft' CHECK(Status IN ('draft', 'published'));
'''

mod_cur.execute(alter_posts_table)
mod_conn.commit()

# Verify the change
mod_cur.execute("PRAGMA table_info(Posts)")
posts_schema = mod_cur.fetchall()
print("📋 UPDATED POSTS TABLE STRUCTURE:")
for column in posts_schema:
    print(f"   - {column[1]}: {column[2]}{' (PK)' if column[5] else ''}")

mod_conn.close()
print("✅ Added Status column with constraints to Posts table")
```

---

## 6. 📚 Comprehensive Summary

### 🎯 What We Learned Today:

1.  **Python-SQLite Integration:**
    - How to connect to SQLite databases from Python
    - Using cursors to execute SQL commands
    - The importance of committing changes
    - Properly closing database connections

2.  **Data Definition Language (DDL):**
    - CREATE TABLE: Building new tables with constraints
    - ALTER TABLE: Modifying existing table structures
    - DROP TABLE: Deleting tables (use with caution!)
    - Common data types and constraints

3.  **Database Design:**
    - Creating relational database schemas
    - Implementing primary and foreign keys
    - Establishing relationships between tables

### 🔑 Key Python-SQLite Methods:

| Method | Purpose | Example |
|:-------|:--------|:--------|
| `sqlite3.connect()` | Connect to database | `conn = sqlite3.connect("db.db")` |
| `connection.cursor()` | Create cursor | `cur = conn.cursor()` |
| `cursor.execute()` | Execute SQL command | `cur.execute("SELECT * FROM table")` |
| `connection.commit()` | Save changes | `conn.commit()` |
| `cursor.fetchall()` | Get all results | `results = cur.fetchall()` |
| `connection.close()` | Close connection | `conn.close()` |

### 💡 Pro Tips:

1.  **Always use parameterized queries** to prevent SQL injection
2.  **Use `IF EXISTS`/`IF NOT EXISTS`** to make your scripts idempotent
3.  **Close connections properly** to avoid database locks
4.  **Test your DDL scripts** on sample data before using them in production
5.  **Use transactions** for multiple related operations

### ✅ Completion Checklist:

- [x] Understand how Python interacts with SQLite databases
- [x] Learn DDL commands: CREATE, ALTER, DROP
- [x] Practice creating tables with various constraints
- [x] Implement primary and foreign key relationships
- [x] Build a complete blog database schema
- [x] Complete bonus challenges

### 🔮 Next Steps:

1.  **Learn Data Manipulation Language (DML)**: INSERT, UPDATE, DELETE
2.  **Practice complex queries**: JOINs across multiple tables
3.  **Explore database migrations**: Managing schema changes over time
4.  **Learn about ORMs**: SQLAlchemy, Django ORM for more abstract database access
5.  **Study database optimization**: Indexes, query planning, performance tuning

```python
print("\n🎉 Congratulations! You've learned how to build databases programmatically!")
print("   You can now create, modify, and manage database structures using Python!")
```
"""

