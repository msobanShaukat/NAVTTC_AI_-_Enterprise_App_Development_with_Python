# -*- coding: utf-8 -*-
"""MD_1: Core_python_&_data_W#4_L#18_(Date:11-Sept-2025)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LYFxhXoqFIwpSJ0JyRolSpgX_oc9lSEn

# ğŸ—„ï¸ Module 1: Core Python & Data - Week 4 Lecture 18
**Date:** 11/09/2025  
**Documented by:** Muhammad Soban Shaukat

## ğŸ”— Integrating Python with SQL (Part 1): Reading from Databases

Welcome to Lecture 18! In our previous sessions, we learned how to create database structures and manipulate data using SQL. Today, we'll learn how to integrate Python with SQL databases to read and display data programmatically.

```python
# Setup: Import necessary libraries
import sqlite3
import pandas as pd
from datetime import datetime, timedelta

print("âœ… Libraries imported successfully!")
```

## ğŸ“‹ Today's Agenda

1.  **ğŸ¤” Why Integrate Python with SQL?**
    *   Understanding the Python-SQLite integration
    *   When to use SQLite for local applications

2.  **ğŸ”Œ SQLite3 Overview & DB-API 2.0 Flow**
    *   Connection, Cursor, Execute, Fetch, Close pattern
    *   Understanding the mental model

3.  **ğŸ“– Reading Data: fetchall(), fetchone(), fetchmany()**
    *   Different methods for retrieving data
    *   When to use each approach

4.  **ğŸ§ª Hands-On: Fetching Posts from Blog Database**
    *   Practical examples with parameterized queries
    *   Formatting output for CLI readability

5.  **ğŸš€ Real-World Challenges & Best Practices**
    *   Connection management, error handling, performance
    *   Bonus exercises for advanced practice

---

## 1. ğŸ¤” Why Integrate Python with SQL?

### ğŸ Python + SQLite: A Powerful Combination

SQLite is a lightweight, serverless database ideal for embedded applications and education. When combined with Python, it creates a powerful tool for data management and automation.

```python
print("ğŸ PYTHON + SQLITE: THE PERFECT MATCH")
print("=" * 40)

print("âœ… Why SQLite is great for learning:")
print("   - Serverless: No installation or configuration needed")
print("   - Single file: Easy to share and backup")
print("   - Zero configuration: Works out of the box")
print("   - Standards compliant: Supports most SQL features")

print("\nâœ… Why Python is great for database work:")
print("   - Built-in sqlite3 module: No additional dependencies")
print("   - Easy data manipulation: Process results with Python")
print("   - Automation: Script complex database operations")
print("   - Visualization: Create reports and dashboards")

print("\nğŸ’¡ Perfect for: Prototyping, learning, small applications, and data analysis!")
```

### ğŸ“Š Where This Fits in Week 4 Plan

This session implements "Connect and Read" from our training plan, focusing on fetching data from SQLite databases using Python.

```python
print("ğŸ“Š WEEK 4 LEARNING PATH:")
print("=" * 30)

week4_path = [
    "Lecture 16: DDL - Building Database Structures",
    "Lecture 17: DML - Manipulating Data",
    "Lecture 18: Python + SQL Part 1 - Reading Data â† YOU ARE HERE",
    "Lecture 19: Python + SQL Part 2 - Writing Data"
]

for i, topic in enumerate(week4_path, 1):
    arrow = "â¡ï¸" if "Part 1" in topic else "   "
    print(f"{arrow} {i}. {topic}")

print("\nğŸ¯ Today's Goal: Learn to read data from SQL databases using Python!")
```

---

## 2. ğŸ”Œ SQLite3 Overview & DB-API 2.0 Flow

### ğŸ§  DB-API Mental Model

The Python Database API (DB-API) provides a consistent interface for working with databases. Here's the mental model:

```python
print("ğŸ§  DB-API 2.0 MENTAL MODEL")
print("=" * 35)

dbapi_flow = [
    "1. CONNECT: Establish connection to database",
    "2. CURSOR: Create a cursor for executing commands",
    "3. EXECUTE: Run SQL statements",
    "4. FETCH: Retrieve results",
    "5. CLOSE: Clean up resources"
]

for step in dbapi_flow:
    print(f"   {step}")

print("\nğŸ“ This pattern works with most databases, not just SQLite!")
```

### ğŸ”§ SQLite3 Essentials

Let's explore the key components of the sqlite3 module:

```python
print("ğŸ”§ SQLITE3 ESSENTIAL COMPONENTS")
print("=" * 35)

components = {
    "Connection": "Represents the database connection. Created with sqlite3.connect()",
    "Cursor": "Used to execute SQL commands and manage results. Created with connection.cursor()",
    "execute()": "Method to run SQL statements. Returns the cursor itself",
    "fetchall()": "Retrieves all results as a list of tuples",
    "fetchone()": "Retrieves one result row",
    "fetchmany()": "Retrieves multiple result rows"
}

for component, description in components.items():
    print(f"   {component:<12} â†’ {description}")
```

### ğŸ’¡ Recommended Approach: Context Managers

Using context managers ensures proper resource cleanup, even if errors occur:

```python
print("\nğŸ’¡ RECOMMENDED: USE CONTEXT MANAGERS")
print("=" * 45)

print("âœ… Benefits of context managers:")
print("   - Automatic connection closing")
print("   - Automatic transaction handling")
print("   - Cleaner code structure")
print("   - Exception safety")

print("\nğŸ“ Syntax:")
print("   with sqlite3.connect('database.db') as conn:")
print("       cursor = conn.cursor()")
print("       # Your database operations here")
```

---

## 3. ğŸ“– Reading Data: Fetch Methods

### ğŸ” Understanding Fetch Methods

SQLite provides three main methods for retrieving data after executing a SELECT query:

```python
# Create a sample database for fetch examples
fetch_conn = sqlite3.connect(":memory:")
fetch_cur = fetch_conn.cursor()

# Create a sample table
fetch_cur.execute('''
CREATE TABLE SamplePosts (
    PostID INTEGER PRIMARY KEY,
    Title TEXT NOT NULL,
    Content TEXT,
    PublishedDate TEXT,
    AuthorID INTEGER
)
''')

# Insert sample data
sample_posts = [
    (1, 'Python Basics', 'Introduction to Python programming', '2025-09-01', 1),
    (2, 'SQL Fundamentals', 'Learning SQL queries', '2025-09-02', 2),
    (3, 'Data Analysis', 'Analyzing data with Python', '2025-09-03', 1),
    (4, 'Web Development', 'Building web applications', '2025-09-04', 3),
    (5, 'Machine Learning', 'Introduction to ML', '2025-09-05', 1)
]

fetch_cur.executemany('''
INSERT INTO SamplePosts (PostID, Title, Content, PublishedDate, AuthorID)
VALUES (?, ?, ?, ?, ?)
''', sample_posts)

fetch_conn.commit()
print("âœ… Created sample database with posts")
```

### ğŸ“‹ fetchall(): Retrieve All Results

```python
print("\nğŸ“‹ FETCHALL(): RETRIEVE ALL RESULTS")
print("=" * 40)

fetch_cur.execute("SELECT * FROM SamplePosts")
all_posts = fetch_cur.fetchall()

print(f"ğŸ“Š Retrieved {len(all_posts)} posts:")
for post in all_posts:
    print(f"   {post[0]}: {post[1]} (by Author {post[4]})")

print("\nğŸ’¡ Use when: You need all results and dataset is small-to-medium size")
```

### ğŸ“‹ fetchone(): Retrieve Single Result

```python
print("\nğŸ“‹ FETCHONE(): RETRIEVE SINGLE RESULT")
print("=" * 45)

fetch_cur.execute("SELECT * FROM SamplePosts ORDER BY PublishedDate DESC")
latest_post = fetch_cur.fetchone()

print("ğŸ“° Latest post:")
print(f"   ID: {latest_post[0]}")
print(f"   Title: {latest_post[1]}")
print(f"   Date: {latest_post[3]}")
print(f"   Author: {latest_post[4]}")

print("\nğŸ’¡ Use when: You expect only one result or want the first result")
```

### ğŸ“‹ fetchmany(): Retrieve Multiple Results

```python
print("\nğŸ“‹ FETCHMANY(): RETRIEVE MULTIPLE RESULTS")
print("=" * 50)

fetch_cur.execute("SELECT * FROM SamplePosts ORDER BY PublishedDate DESC")
recent_posts = fetch_cur.fetchmany(3)

print("ğŸ“° 3 most recent posts:")
for post in recent_posts:
    print(f"   {post[0]}: {post[1]} ({post[3]})")

print("\nğŸ’¡ Use when: You want to limit results for pagination or preview")
```

### ğŸ”’ Safety with Parameterized Queries

Always use parameterized queries to prevent SQL injection attacks:

```python
print("\nğŸ”’ PARAMETERIZED QUERIES: SAFETY FIRST!")
print("=" * 50)

# UNSAFE: String concatenation (VULNERABLE to SQL injection)
author_id = 1
unsafe_query = f"SELECT * FROM SamplePosts WHERE AuthorID = {author_id}"

# SAFE: Parameterized queries (RECOMMENDED)
safe_query = "SELECT * FROM SamplePosts WHERE AuthorID = ?"

fetch_cur.execute(safe_query, (author_id,))
author_posts = fetch_cur.fetchall()

print(f"âœ… Safe parameterized query retrieved {len(author_posts)} posts")
print("ğŸ“ Always use ? placeholders and pass values as tuples")

# Close sample database
fetch_conn.close()
```

---

## 4. ğŸ§ª Hands-On: Fetching Posts from Blog Database

### ğŸ¯ Class Example: Connect and List Posts

Let's create a comprehensive example that connects to a blog database and fetches posts:

```python
print("ğŸ¯ CLASS EXAMPLE: CONNECT AND LIST POSTS")
print("=" * 45)

# First, create a blog database with sample data
blog_conn = sqlite3.connect("blog.db")
blog_cur = blog_conn.cursor()

# Create tables
blog_cur.execute('''
CREATE TABLE IF NOT EXISTS Users (
    UserID INTEGER PRIMARY KEY,
    Username TEXT UNIQUE NOT NULL,
    Email TEXT UNIQUE NOT NULL
)
''')

blog_cur.execute('''
CREATE TABLE IF NOT EXISTS Posts (
    PostID INTEGER PRIMARY KEY,
    Title TEXT NOT NULL,
    Content TEXT,
    PublishedDate TEXT,
    AuthorID INTEGER,
    FOREIGN KEY (AuthorID) REFERENCES Users(UserID)
)
''')

# Insert sample users
users = [
    (1, 'alice_dev', 'alice@example.com'),
    (2, 'bob_writer', 'bob@example.com'),
    (3, 'charlie_author', 'charlie@example.com')
]

blog_cur.executemany("INSERT OR IGNORE INTO Users VALUES (?, ?, ?)", users)

# Insert sample posts
posts = [
    (1, 'Introduction to Python', 'Python is a versatile programming language...', '2025-09-01', 1),
    (2, 'SQL Basics', 'SQL is used to manage relational databases...', '2025-09-02', 2),
    (3, 'Data Visualization', 'Learn to create beautiful visualizations...', '2025-09-03', 1),
    (4, 'Web Frameworks', 'Comparing Django vs Flask...', '2025-09-04', 3),
    (5, 'Machine Learning', 'Introduction to scikit-learn...', '2025-09-05', 1),
    (6, 'Database Design', 'Principles of good database design...', '2025-09-06', 2)
]

blog_cur.executemany("INSERT OR IGNORE INTO Posts VALUES (?, ?, ?, ?, ?)", posts)

blog_conn.commit()
print("âœ… Created blog database with sample data")
```

### ğŸ“‹ Minimal Connection and Fetch Example

```python
print("\nğŸ“‹ MINIMAL CONNECTION AND FETCH EXAMPLE")
print("=" * 50)

# Simple approach (not recommended for production)
conn = sqlite3.connect("blog.db")
cur = conn.cursor()

cur.execute("SELECT PostID, Title, PublishedDate, AuthorID FROM Posts;")
rows = cur.fetchall()

print("ğŸ“ All posts (simple format):")
for row in rows:
    print(f"   ID={row[0]} | Title={row[1]} | Date={row[2]} | AuthorID={row[3]}")

conn.close()
print("âœ… Connection closed")
```

### ğŸ’¡ Recommended: Context Manager Approach

```python
print("\nğŸ’¡ RECOMMENDED: CONTEXT MANAGER APPROACH")
print("=" * 55)

# Recommended approach using context manager
try:
    with sqlite3.connect("blog.db") as conn:
        cur = conn.cursor()
        cur.execute('''
            SELECT PostID, Title, PublishedDate, AuthorID
            FROM Posts
            ORDER BY PublishedDate DESC;
        ''')
        rows = cur.fetchall()
        
        print("ğŸ“ All posts (formatted):")
        print("-" * 70)
        for row in rows:
            print(f"   [{row[0]}] {row[1]:<25} {row[2]:<12} Author={row[3]}")
        print("-" * 70)
        
except sqlite3.Error as e:
    print(f"âŒ Database error: {e}")
```

### ğŸ” Handling Empty Results

```python
print("\nğŸ” HANDLING EMPTY RESULTS")
print("=" * 35)

# Test with a query that returns no results
try:
    with sqlite3.connect("blog.db") as conn:
        cur = conn.cursor()
        cur.execute("SELECT * FROM Posts WHERE Title LIKE '%Nonexistent%'")
        rows = cur.fetchall()
        
        if not rows:
            print("â„¹ï¸  No posts found matching the criteria")
        else:
            print(f"ğŸ“ Found {len(rows)} posts")
            
except sqlite3.Error as e:
    print(f"âŒ Database error: {e}")
```

### ğŸ¨ Formatting Output for CLI Readability

```python
print("\nğŸ¨ FORMATTING OUTPUT FOR CLI READABILITY")
print("=" * 55)

try:
    with sqlite3.connect("blog.db") as conn:
        cur = conn.cursor()
        cur.execute('''
            SELECT PostID, Title, PublishedDate, AuthorID
            FROM Posts
            ORDER BY PublishedDate DESC;
        ''')
        rows = cur.fetchall()
        
        if not rows:
            print("No posts found.")
        else:
            print("\nğŸ“ BLOG POSTS")
            print("=" * 70)
            print(f"{'ID':<4} {'Title':<25} {'Date':<12} {'Author':<10}")
            print("-" * 70)
            
            for row in rows:
                # Truncate long titles for better formatting
                title = row[1] if len(row[1]) <= 24 else row[1][:21] + "..."
                print(f"{row[0]:<4} {title:<25} {row[2]:<12} {row[3]:<10}")
            
            print("=" * 70)
            print(f"Total posts: {len(rows)}")
            
except sqlite3.Error as e:
    print(f"âŒ Database error: {e}")
```

---

## 5. ğŸš€ Real-World Challenges & Best Practices

### ğŸ”§ Parameterized Queries with Filtering

```python
print("ğŸ”§ PARAMETERIZED QUERIES WITH FILTERING")
print("=" * 50)

def get_posts_by_author(author_id):
    '''Get posts by a specific author using parameterized query'''
    try:
        with sqlite3.connect("blog.db") as conn:
            cur = conn.cursor()
            cur.execute('''
                SELECT PostID, Title, PublishedDate
                FROM Posts
                WHERE AuthorID = ?
                ORDER BY PublishedDate DESC;
            ''', (author_id,))
            
            rows = cur.fetchall()
            return rows
            
    except sqlite3.Error as e:
        print(f"âŒ Database error: {e}")
        return []

# Test the function
author_id = 1
posts = get_posts_by_author(author_id)

print(f"ğŸ“ Posts by Author {author_id}:")
if posts:
    for post in posts:
        print(f"   {post[0]}: {post[1]} ({post[2]})")
else:
    print("   No posts found for this author")
```

### ğŸ” Search Functionality with LIKE

```python
print("\nğŸ” SEARCH FUNCTIONALITY WITH LIKE")
print("=" * 45)

def search_posts(search_term):
    '''Search posts by title or content'''
    try:
        with sqlite3.connect("blog.db") as conn:
            cur = conn.cursor()
            search_pattern = f"%{search_term}%"
            
            cur.execute('''
                SELECT PostID, Title, PublishedDate, AuthorID
                FROM Posts
                WHERE Title LIKE ? OR Content LIKE ?
                ORDER BY PublishedDate DESC;
            ''', (search_pattern, search_pattern))
            
            rows = cur.fetchall()
            return rows
            
    except sqlite3.Error as e:
        print(f"âŒ Database error: {e}")
        return []

# Test search function
search_term = "Python"
results = search_posts(search_term)

print(f"ğŸ” Search results for '{search_term}':")
if results:
    for post in results:
        print(f"   {post[0]}: {post[1]} ({post[2]})")
else:
    print("   No matching posts found")
```

### ğŸ“Š Database Introspection

```python
print("\nğŸ“Š DATABASE INTROSPECTION")
print("=" * 35)

try:
    with sqlite3.connect("blog.db") as conn:
        cur = conn.cursor()
        
        # Get table information
        cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cur.fetchall()
        
        print("ğŸ“‹ Database tables:")
        for table in tables:
            print(f"   - {table[0]}")
        
        # Get Posts table schema
        print("\nğŸ“‹ Posts table schema:")
        cur.execute("PRAGMA table_info(Posts);")
        columns = cur.fetchall()
        
        for column in columns:
            print(f"   - {column[1]}: {column[2]}{' (PK)' if column[5] else ''}")
            
except sqlite3.Error as e:
    print(f"âŒ Database error: {e}")
```

### âš¡ Performance Considerations

```python
print("\nâš¡ PERFORMANCE CONSIDERATIONS")
print("=" * 40)

try:
    with sqlite3.connect("blog.db") as conn:
        cur = conn.cursor()
        
        # Using LIMIT for pagination
        print("ğŸ“‘ Pagination example (first 3 posts):")
        cur.execute('''
            SELECT PostID, Title, PublishedDate
            FROM Posts
            ORDER BY PublishedDate DESC
            LIMIT 3;
        ''')
        
        first_page = cur.fetchall()
        for post in first_page:
            print(f"   {post[0]}: {post[1]}")
        
        # Using OFFSET for next page
        print("\nğŸ“‘ Next page (posts 4-6):")
        cur.execute('''
            SELECT PostID, Title, PublishedDate
            FROM Posts
            ORDER BY PublishedDate DESC
            LIMIT 3 OFFSET 3;
        ''')
        
        second_page = cur.fetchall()
        for post in second_page:
            print(f"   {post[0]}: {post[1]}")
            
except sqlite3.Error as e:
    print(f"âŒ Database error: {e}")
```

---

## 6. ğŸ¯ Bonus Exercises

### ğŸ† Bonus Challenge 1: Recent Posts

```python
print("ğŸ† BONUS CHALLENGE 1: RECENT POSTS")
print("=" * 40)

def get_recent_posts(days=7):
    '''Get posts from the last N days'''
    try:
        with sqlite3.connect("blog.db") as conn:
            cur = conn.cursor()
            
            # Calculate date threshold
            threshold_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')
            
            cur.execute('''
                SELECT PostID, Title, PublishedDate
                FROM Posts
                WHERE PublishedDate >= ?
                ORDER BY PublishedDate DESC;
            ''', (threshold_date,))
            
            return cur.fetchall()
            
    except sqlite3.Error as e:
        print(f"âŒ Database error: {e}")
        return []

# Test recent posts function
recent_posts = get_recent_posts(5)
print("ğŸ“° Posts from the last 5 days:")
if recent_posts:
    for post in recent_posts:
        print(f"   {post[0]}: {post[1]} ({post[2]})")
else:
    print("   No recent posts found")
```

### ğŸ† Bonus Challenge 2: Post Detail View

```python
print("\nğŸ† BONUS CHALLENGE 2: POST DETAIL VIEW")
print("=" * 45)

def get_post_detail(post_id):
    '''Get complete details for a specific post'''
    try:
        with sqlite3.connect("blog.db") as conn:
            cur = conn.cursor()
            
            cur.execute('''
                SELECT p.PostID, p.Title, p.Content, p.PublishedDate,
                       u.UserID, u.Username
                FROM Posts p
                JOIN Users u ON p.AuthorID = u.UserID
                WHERE p.PostID = ?;
            ''', (post_id,))
            
            return cur.fetchone()
            
    except sqlite3.Error as e:
        print(f"âŒ Database error: {e}")
        return None

# Test post detail function
post_detail = get_post_detail(1)
if post_detail:
    print("ğŸ“„ POST DETAIL:")
    print(f"   ID: {post_detail[0]}")
    print(f"   Title: {post_detail[1]}")
    print(f"   Content: {post_detail[2][:100]}...")  # Preview first 100 chars
    print(f"   Published: {post_detail[3]}")
    print(f"   Author: {post_detail[5]} (ID: {post_detail[4]})")
else:
    print("   Post not found")
```

### ğŸ† Bonus Challenge 3: Author Statistics

```python
print("\nğŸ† BONUS CHALLENGE 3: AUTHOR STATISTICS")
print("=" * 45)

def get_author_stats():
    '''Get statistics about authors and their posts'''
    try:
        with sqlite3.connect("blog.db") as conn:
            cur = conn.cursor()
            
            cur.execute('''
                SELECT u.UserID, u.Username, COUNT(p.PostID) as PostCount,
                       MIN(p.PublishedDate) as FirstPost,
                       MAX(p.PublishedDate) as LatestPost
                FROM Users u
                LEFT JOIN Posts p ON u.UserID = p.AuthorID
                GROUP BY u.UserID, u.Username
                ORDER BY PostCount DESC;
            ''')
            
            return cur.fetchall()
            
    except sqlite3.Error as e:
        print(f"âŒ Database error: {e}")
        return []

# Test author stats function
author_stats = get_author_stats()
print("ğŸ“Š AUTHOR STATISTICS:")
print("-" * 60)
print(f"{'Author':<15} {'Posts':<6} {'First Post':<12} {'Latest Post':<12}")
print("-" * 60)
for stats in author_stats:
    username = stats[1]
    post_count = stats[2] if stats[2] else 0
    first_post = stats[3] if stats[3] else "N/A"
    latest_post = stats[4] if stats[4] else "N/A"
    
    print(f"{username:<15} {post_count:<6} {first_post:<12} {latest_post:<12}")
```

---

## 7. ğŸ“š Comprehensive Summary

### ğŸ¯ What We Learned Today:

1.  **Python-SQLite Integration:**
    - How to connect to SQLite databases from Python
    - Using the DB-API 2.0 pattern: Connect â†’ Cursor â†’ Execute â†’ Fetch â†’ Close
    - The importance of context managers for resource management

2.  **Reading Data:**
    - Different fetch methods: fetchall(), fetchone(), fetchmany()
    - When to use each approach based on your needs
    - Formatting query results for CLI readability

3.  **Best Practices:**
    - Always use parameterized queries to prevent SQL injection
    - Handle empty results gracefully
    - Use proper error handling with try-except blocks
    - Implement pagination for large datasets

### ğŸ”‘ Key Python-SQLite Methods:

| Method | Purpose | Example |
|:-------|:--------|:--------|
| `sqlite3.connect()` | Connect to database | `conn = sqlite3.connect("db.db")` |
| `connection.cursor()` | Create cursor | `cur = conn.cursor()` |
| `cursor.execute()` | Execute SQL command | `cur.execute("SELECT * FROM table")` |
| `cursor.fetchall()` | Get all results | `results = cur.fetchall()` |
| `cursor.fetchone()` | Get single result | `result = cur.fetchone()` |
| `cursor.fetchmany()` | Get multiple results | `results = cur.fetchmany(5)` |
| `connection.close()` | Close connection | `conn.close()` |

### ğŸ’¡ Pro Tips:

1.  **Use context managers** for automatic connection handling
2.  **Always parameterize queries** to prevent SQL injection
3.  **Handle empty results** to provide good user experience
4.  **Use LIMIT and OFFSET** for pagination with large datasets
5.  **Close connections properly** to avoid database locks

### âœ… Completion Checklist:

- [x] Understand how to connect to SQLite databases from Python
- [x] Learn different fetch methods and when to use them
- [x] Practice parameterized queries for safety
- [x] Implement proper error handling
- [x] Format query results for CLI readability
- [x] Complete bonus challenges

### ğŸ”® Next Steps:

1.  **Python + SQL Part 2**: Learn to insert, update, and delete data
2.  **Advanced queries**: JOIN operations across multiple tables
3.  **Database transactions**: BEGIN, COMMIT, ROLLBACK
4.  **ORM frameworks**: SQLAlchemy, Django ORM
5.  **Web integration**: Creating web APIs that interact with databases

```python
print("\nğŸ‰ Congratulations! You've mastered reading data from SQL databases using Python!")
print("   You're now ready to build applications that can retrieve and display database content!")
```

This comprehensive Colab notebook covers all the concepts from Lecture 18, with detailed explanations, practical examples, and hands-on exercises. You've learned how to read data from SQL databases using Python effectively and safely!
"""

